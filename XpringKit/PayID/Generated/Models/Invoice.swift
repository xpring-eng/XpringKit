//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class Invoice: APIModel {

    public var nonce: String

    public var expirationTime: String

    public var paymentInformation: PaymentInformation

    public var complianceRequirements: [String]

    public var complianceHashes: [ComplianceHashes]?

    public var memo: String?

    public class ComplianceHashes: APIModel {

        public var hash: String?

        public var type: String?

        public init(hash: String? = nil, type: String? = nil) {
            self.hash = hash
            self.type = type
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            hash = try container.decodeIfPresent("hash")
            type = try container.decodeIfPresent("type")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(hash, forKey: "hash")
            try container.encodeIfPresent(type, forKey: "type")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? ComplianceHashes else { return false }
          guard self.hash == object.hash else { return false }
          guard self.type == object.type else { return false }
          return true
        }

        public static func == (lhs: ComplianceHashes, rhs: ComplianceHashes) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(nonce: String, expirationTime: String, paymentInformation: PaymentInformation, complianceRequirements: [String], complianceHashes: [ComplianceHashes]? = nil, memo: String? = nil) {
        self.nonce = nonce
        self.expirationTime = expirationTime
        self.paymentInformation = paymentInformation
        self.complianceRequirements = complianceRequirements
        self.complianceHashes = complianceHashes
        self.memo = memo
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        nonce = try container.decode("nonce")
        expirationTime = try container.decode("expirationTime")
        paymentInformation = try container.decode("paymentInformation")
        complianceRequirements = try container.decodeArray("complianceRequirements")
        complianceHashes = try container.decodeArrayIfPresent("complianceHashes")
        memo = try container.decodeIfPresent("memo")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encode(nonce, forKey: "nonce")
        try container.encode(expirationTime, forKey: "expirationTime")
        try container.encode(paymentInformation, forKey: "paymentInformation")
        try container.encode(complianceRequirements, forKey: "complianceRequirements")
        try container.encodeIfPresent(complianceHashes, forKey: "complianceHashes")
        try container.encodeIfPresent(memo, forKey: "memo")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? Invoice else { return false }
      guard self.nonce == object.nonce else { return false }
      guard self.expirationTime == object.expirationTime else { return false }
      guard self.paymentInformation == object.paymentInformation else { return false }
      guard self.complianceRequirements == object.complianceRequirements else { return false }
      guard self.complianceHashes == object.complianceHashes else { return false }
      guard self.memo == object.memo else { return false }
      return true
    }

    public static func == (lhs: Invoice, rhs: Invoice) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
