// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc/v1/ledger_objects.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Rpc_V1_LedgerEntryType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case accountRoot // = 1
  case amendments // = 2
  case check // = 3
  case depositPreauth // = 4
  case directoryNode // = 5
  case escrow // = 6
  case feeSettings // = 7
  case ledgerHashes // = 8
  case offer // = 9
  case payChannel // = 10
  case rippleState // = 11
  case signerList // = 12
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .accountRoot
    case 2: self = .amendments
    case 3: self = .check
    case 4: self = .depositPreauth
    case 5: self = .directoryNode
    case 6: self = .escrow
    case 7: self = .feeSettings
    case 8: self = .ledgerHashes
    case 9: self = .offer
    case 10: self = .payChannel
    case 11: self = .rippleState
    case 12: self = .signerList
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .accountRoot: return 1
    case .amendments: return 2
    case .check: return 3
    case .depositPreauth: return 4
    case .directoryNode: return 5
    case .escrow: return 6
    case .feeSettings: return 7
    case .ledgerHashes: return 8
    case .offer: return 9
    case .payChannel: return 10
    case .rippleState: return 11
    case .signerList: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Rpc_V1_LedgerEntryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rpc_V1_LedgerEntryType] = [
    .unspecified,
    .accountRoot,
    .amendments,
    .check,
    .depositPreauth,
    .directoryNode,
    .escrow,
    .feeSettings,
    .ledgerHashes,
    .offer,
    .payChannel,
    .rippleState,
    .signerList,
  ]
}

#endif  // swift(>=4.2)

public struct Rpc_V1_LedgerObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var object: OneOf_Object? {
    get {return _storage._object}
    set {_uniqueStorage()._object = newValue}
  }

  public var accountRoot: Rpc_V1_AccountRoot {
    get {
      if case .accountRoot(let v)? = _storage._object {return v}
      return Rpc_V1_AccountRoot()
    }
    set {_uniqueStorage()._object = .accountRoot(newValue)}
  }

  public var rippleState: Rpc_V1_RippleState {
    get {
      if case .rippleState(let v)? = _storage._object {return v}
      return Rpc_V1_RippleState()
    }
    set {_uniqueStorage()._object = .rippleState(newValue)}
  }

  public var offer: Rpc_V1_Offer {
    get {
      if case .offer(let v)? = _storage._object {return v}
      return Rpc_V1_Offer()
    }
    set {_uniqueStorage()._object = .offer(newValue)}
  }

  public var signerList: Rpc_V1_SignerList {
    get {
      if case .signerList(let v)? = _storage._object {return v}
      return Rpc_V1_SignerList()
    }
    set {_uniqueStorage()._object = .signerList(newValue)}
  }

  public var directoryNode: Rpc_V1_DirectoryNode {
    get {
      if case .directoryNode(let v)? = _storage._object {return v}
      return Rpc_V1_DirectoryNode()
    }
    set {_uniqueStorage()._object = .directoryNode(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Object: Equatable {
    case accountRoot(Rpc_V1_AccountRoot)
    case rippleState(Rpc_V1_RippleState)
    case offer(Rpc_V1_Offer)
    case signerList(Rpc_V1_SignerList)
    case directoryNode(Rpc_V1_DirectoryNode)

  #if !swift(>=4.1)
    public static func ==(lhs: Rpc_V1_LedgerObject.OneOf_Object, rhs: Rpc_V1_LedgerObject.OneOf_Object) -> Bool {
      switch (lhs, rhs) {
      case (.accountRoot(let l), .accountRoot(let r)): return l == r
      case (.rippleState(let l), .rippleState(let r)): return l == r
      case (.offer(let l), .offer(let r)): return l == r
      case (.signerList(let l), .signerList(let r)): return l == r
      case (.directoryNode(let l), .directoryNode(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_DirectoryNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// 32 bytes
  public var rootIndex: Data {
    get {return _storage._rootIndex}
    set {_uniqueStorage()._rootIndex = newValue}
  }

  public var indexes: [Data] {
    get {return _storage._indexes}
    set {_uniqueStorage()._indexes = newValue}
  }

  public var indexNext: UInt64 {
    get {return _storage._indexNext}
    set {_uniqueStorage()._indexNext = newValue}
  }

  public var indexPrevious: UInt64 {
    get {return _storage._indexPrevious}
    set {_uniqueStorage()._indexPrevious = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var takerPaysCurrency: Rpc_V1_Currency {
    get {return _storage._takerPaysCurrency ?? Rpc_V1_Currency()}
    set {_uniqueStorage()._takerPaysCurrency = newValue}
  }
  /// Returns true if `takerPaysCurrency` has been explicitly set.
  public var hasTakerPaysCurrency: Bool {return _storage._takerPaysCurrency != nil}
  /// Clears the value of `takerPaysCurrency`. Subsequent reads from it will return its default value.
  public mutating func clearTakerPaysCurrency() {_uniqueStorage()._takerPaysCurrency = nil}

  /// 20 bytes
  public var takerPaysIssuer: Data {
    get {return _storage._takerPaysIssuer}
    set {_uniqueStorage()._takerPaysIssuer = newValue}
  }

  public var takerGetsCurrency: Rpc_V1_Currency {
    get {return _storage._takerGetsCurrency ?? Rpc_V1_Currency()}
    set {_uniqueStorage()._takerGetsCurrency = newValue}
  }
  /// Returns true if `takerGetsCurrency` has been explicitly set.
  public var hasTakerGetsCurrency: Bool {return _storage._takerGetsCurrency != nil}
  /// Clears the value of `takerGetsCurrency`. Subsequent reads from it will return its default value.
  public mutating func clearTakerGetsCurrency() {_uniqueStorage()._takerGetsCurrency = nil}

  /// 20 bytes
  public var takerGetsIssuer: Data {
    get {return _storage._takerGetsIssuer}
    set {_uniqueStorage()._takerGetsIssuer = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_SignerList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var flags: UInt32 = 0

  /// 32 bytes
  public var previousTxnID: Data = SwiftProtobuf.Internal.emptyData

  public var previousTransactionLedgerSequence: UInt32 = 0

  public var ownerNode: UInt64 = 0

  public var signerEntries: [Rpc_V1_SignerEntry] = []

  public var signerListID: UInt32 = 0

  public var signerQuorum: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rpc_V1_SignerEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Rpc_V1_AccountAddress {
    get {return _storage._account ?? Rpc_V1_AccountAddress()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  /// this is actually uint16, but protobuf can't express uint16
  public var signerWeight: UInt32 {
    get {return _storage._signerWeight}
    set {_uniqueStorage()._signerWeight = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_AccountRoot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Rpc_V1_AccountAddress {
    get {return _storage._account ?? Rpc_V1_AccountAddress()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  public var balance: Rpc_V1_XRPDropsAmount {
    get {return _storage._balance ?? Rpc_V1_XRPDropsAmount()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var sequence: UInt32 {
    get {return _storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  public var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  public var ownerCount: UInt32 {
    get {return _storage._ownerCount}
    set {_uniqueStorage()._ownerCount = newValue}
  }

  /// 32 bytes
  public var previousTransactionID: Data {
    get {return _storage._previousTransactionID}
    set {_uniqueStorage()._previousTransactionID = newValue}
  }

  public var previousTransactionLedgerSequence: UInt32 {
    get {return _storage._previousTransactionLedgerSequence}
    set {_uniqueStorage()._previousTransactionLedgerSequence = newValue}
  }

  /// 32 bytes
  public var accountTransactionID: Data {
    get {return _storage._accountTransactionID}
    set {_uniqueStorage()._accountTransactionID = newValue}
  }

  /// Variable length
  public var domain: Data {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// 16 bytes
  public var emailHash: Data {
    get {return _storage._emailHash}
    set {_uniqueStorage()._emailHash = newValue}
  }

  /// Variable length
  public var messageKey: Data {
    get {return _storage._messageKey}
    set {_uniqueStorage()._messageKey = newValue}
  }

  /// base58 encoding
  public var regularKey: String {
    get {return _storage._regularKey}
    set {_uniqueStorage()._regularKey = newValue}
  }

  public var tickSize: UInt32 {
    get {return _storage._tickSize}
    set {_uniqueStorage()._tickSize = newValue}
  }

  public var transferRate: UInt32 {
    get {return _storage._transferRate}
    set {_uniqueStorage()._transferRate = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_RippleState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var balance: Rpc_V1_CurrencyAmount {
    get {return _storage._balance ?? Rpc_V1_CurrencyAmount()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  public var lowLimit: Rpc_V1_CurrencyAmount {
    get {return _storage._lowLimit ?? Rpc_V1_CurrencyAmount()}
    set {_uniqueStorage()._lowLimit = newValue}
  }
  /// Returns true if `lowLimit` has been explicitly set.
  public var hasLowLimit: Bool {return _storage._lowLimit != nil}
  /// Clears the value of `lowLimit`. Subsequent reads from it will return its default value.
  public mutating func clearLowLimit() {_uniqueStorage()._lowLimit = nil}

  public var highLimit: Rpc_V1_CurrencyAmount {
    get {return _storage._highLimit ?? Rpc_V1_CurrencyAmount()}
    set {_uniqueStorage()._highLimit = newValue}
  }
  /// Returns true if `highLimit` has been explicitly set.
  public var hasHighLimit: Bool {return _storage._highLimit != nil}
  /// Clears the value of `highLimit`. Subsequent reads from it will return its default value.
  public mutating func clearHighLimit() {_uniqueStorage()._highLimit = nil}

  public var lowNode: UInt64 {
    get {return _storage._lowNode}
    set {_uniqueStorage()._lowNode = newValue}
  }

  public var highNode: UInt64 {
    get {return _storage._highNode}
    set {_uniqueStorage()._highNode = newValue}
  }

  public var lowQualityIn: UInt32 {
    get {return _storage._lowQualityIn}
    set {_uniqueStorage()._lowQualityIn = newValue}
  }

  public var lowQualityOut: UInt32 {
    get {return _storage._lowQualityOut}
    set {_uniqueStorage()._lowQualityOut = newValue}
  }

  public var highQualityIn: UInt32 {
    get {return _storage._highQualityIn}
    set {_uniqueStorage()._highQualityIn = newValue}
  }

  public var highQualityOut: UInt32 {
    get {return _storage._highQualityOut}
    set {_uniqueStorage()._highQualityOut = newValue}
  }

  /// 32 bytes
  public var previousTransactionID: Data {
    get {return _storage._previousTransactionID}
    set {_uniqueStorage()._previousTransactionID = newValue}
  }

  public var previousTransactionLedgerSequence: UInt32 {
    get {return _storage._previousTransactionLedgerSequence}
    set {_uniqueStorage()._previousTransactionLedgerSequence = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_Offer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String {
    get {return _storage._account}
    set {_uniqueStorage()._account = newValue}
  }

  public var sequence: UInt32 {
    get {return _storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  public var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  public var takerPays: Rpc_V1_CurrencyAmount {
    get {return _storage._takerPays ?? Rpc_V1_CurrencyAmount()}
    set {_uniqueStorage()._takerPays = newValue}
  }
  /// Returns true if `takerPays` has been explicitly set.
  public var hasTakerPays: Bool {return _storage._takerPays != nil}
  /// Clears the value of `takerPays`. Subsequent reads from it will return its default value.
  public mutating func clearTakerPays() {_uniqueStorage()._takerPays = nil}

  public var takerGets: Rpc_V1_CurrencyAmount {
    get {return _storage._takerGets ?? Rpc_V1_CurrencyAmount()}
    set {_uniqueStorage()._takerGets = newValue}
  }
  /// Returns true if `takerGets` has been explicitly set.
  public var hasTakerGets: Bool {return _storage._takerGets != nil}
  /// Clears the value of `takerGets`. Subsequent reads from it will return its default value.
  public mutating func clearTakerGets() {_uniqueStorage()._takerGets = nil}

  public var bookDirectory: Data {
    get {return _storage._bookDirectory}
    set {_uniqueStorage()._bookDirectory = newValue}
  }

  public var bookNode: UInt64 {
    get {return _storage._bookNode}
    set {_uniqueStorage()._bookNode = newValue}
  }

  public var ownerNode: UInt64 {
    get {return _storage._ownerNode}
    set {_uniqueStorage()._ownerNode = newValue}
  }

  public var expiration: UInt32 {
    get {return _storage._expiration}
    set {_uniqueStorage()._expiration = newValue}
  }

  /// 32 bytes
  public var previousTransactionID: Data {
    get {return _storage._previousTransactionID}
    set {_uniqueStorage()._previousTransactionID = newValue}
  }

  public var previousTransactionLedgerSequence: UInt32 {
    get {return _storage._previousTransactionLedgerSequence}
    set {_uniqueStorage()._previousTransactionLedgerSequence = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rpc.v1"

extension Rpc_V1_LedgerEntryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEDGER_ENTRY_TYPE_UNSPECIFIED"),
    1: .same(proto: "LEDGER_ENTRY_TYPE_ACCOUNT_ROOT"),
    2: .same(proto: "LEDGER_ENTRY_TYPE_AMENDMENTS"),
    3: .same(proto: "LEDGER_ENTRY_TYPE_CHECK"),
    4: .same(proto: "LEDGER_ENTRY_TYPE_DEPOSIT_PREAUTH"),
    5: .same(proto: "LEDGER_ENTRY_TYPE_DIRECTORY_NODE"),
    6: .same(proto: "LEDGER_ENTRY_TYPE_ESCROW"),
    7: .same(proto: "LEDGER_ENTRY_TYPE_FEE_SETTINGS"),
    8: .same(proto: "LEDGER_ENTRY_TYPE_LEDGER_HASHES"),
    9: .same(proto: "LEDGER_ENTRY_TYPE_OFFER"),
    10: .same(proto: "LEDGER_ENTRY_TYPE_PAY_CHANNEL"),
    11: .same(proto: "LEDGER_ENTRY_TYPE_RIPPLE_STATE"),
    12: .same(proto: "LEDGER_ENTRY_TYPE_SIGNER_LIST"),
  ]
}

extension Rpc_V1_LedgerObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LedgerObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_root"),
    2: .standard(proto: "ripple_state"),
    3: .same(proto: "offer"),
    4: .standard(proto: "signer_list"),
    5: .standard(proto: "directory_node"),
  ]

  fileprivate class _StorageClass {
    var _object: Rpc_V1_LedgerObject.OneOf_Object?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _object = source._object
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Rpc_V1_AccountRoot?
          if let current = _storage._object {
            try decoder.handleConflictingOneOf()
            if case .accountRoot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._object = .accountRoot(v)}
        case 2:
          var v: Rpc_V1_RippleState?
          if let current = _storage._object {
            try decoder.handleConflictingOneOf()
            if case .rippleState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._object = .rippleState(v)}
        case 3:
          var v: Rpc_V1_Offer?
          if let current = _storage._object {
            try decoder.handleConflictingOneOf()
            if case .offer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._object = .offer(v)}
        case 4:
          var v: Rpc_V1_SignerList?
          if let current = _storage._object {
            try decoder.handleConflictingOneOf()
            if case .signerList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._object = .signerList(v)}
        case 5:
          var v: Rpc_V1_DirectoryNode?
          if let current = _storage._object {
            try decoder.handleConflictingOneOf()
            if case .directoryNode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._object = .directoryNode(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._object {
      case .accountRoot(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .rippleState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .offer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .signerList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .directoryNode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_LedgerObject, rhs: Rpc_V1_LedgerObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._object != rhs_storage._object {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_DirectoryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirectoryNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .standard(proto: "root_index"),
    3: .same(proto: "indexes"),
    4: .standard(proto: "index_next"),
    5: .standard(proto: "index_previous"),
    6: .same(proto: "owner"),
    7: .standard(proto: "taker_pays_currency"),
    8: .standard(proto: "taker_pays_issuer"),
    9: .standard(proto: "taker_gets_currency"),
    10: .standard(proto: "taker_gets_issuer"),
  ]

  fileprivate class _StorageClass {
    var _flags: UInt32 = 0
    var _rootIndex: Data = SwiftProtobuf.Internal.emptyData
    var _indexes: [Data] = []
    var _indexNext: UInt64 = 0
    var _indexPrevious: UInt64 = 0
    var _owner: String = String()
    var _takerPaysCurrency: Rpc_V1_Currency? = nil
    var _takerPaysIssuer: Data = SwiftProtobuf.Internal.emptyData
    var _takerGetsCurrency: Rpc_V1_Currency? = nil
    var _takerGetsIssuer: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _flags = source._flags
      _rootIndex = source._rootIndex
      _indexes = source._indexes
      _indexNext = source._indexNext
      _indexPrevious = source._indexPrevious
      _owner = source._owner
      _takerPaysCurrency = source._takerPaysCurrency
      _takerPaysIssuer = source._takerPaysIssuer
      _takerGetsCurrency = source._takerGetsCurrency
      _takerGetsIssuer = source._takerGetsIssuer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._rootIndex)
        case 3: try decoder.decodeRepeatedBytesField(value: &_storage._indexes)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._indexNext)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._indexPrevious)
        case 6: try decoder.decodeSingularStringField(value: &_storage._owner)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._takerPaysCurrency)
        case 8: try decoder.decodeSingularBytesField(value: &_storage._takerPaysIssuer)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._takerGetsCurrency)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._takerGetsIssuer)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 1)
      }
      if !_storage._rootIndex.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rootIndex, fieldNumber: 2)
      }
      if !_storage._indexes.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._indexes, fieldNumber: 3)
      }
      if _storage._indexNext != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._indexNext, fieldNumber: 4)
      }
      if _storage._indexPrevious != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._indexPrevious, fieldNumber: 5)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 6)
      }
      if let v = _storage._takerPaysCurrency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._takerPaysIssuer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._takerPaysIssuer, fieldNumber: 8)
      }
      if let v = _storage._takerGetsCurrency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._takerGetsIssuer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._takerGetsIssuer, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_DirectoryNode, rhs: Rpc_V1_DirectoryNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._rootIndex != rhs_storage._rootIndex {return false}
        if _storage._indexes != rhs_storage._indexes {return false}
        if _storage._indexNext != rhs_storage._indexNext {return false}
        if _storage._indexPrevious != rhs_storage._indexPrevious {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._takerPaysCurrency != rhs_storage._takerPaysCurrency {return false}
        if _storage._takerPaysIssuer != rhs_storage._takerPaysIssuer {return false}
        if _storage._takerGetsCurrency != rhs_storage._takerGetsCurrency {return false}
        if _storage._takerGetsIssuer != rhs_storage._takerGetsIssuer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_SignerList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignerList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .standard(proto: "previous_txn_id"),
    3: .standard(proto: "previous_transaction_ledger_sequence"),
    4: .standard(proto: "owner_node"),
    5: .standard(proto: "signer_entries"),
    6: .standard(proto: "signer_list_id"),
    7: .standard(proto: "signer_quorum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.flags)
      case 2: try decoder.decodeSingularBytesField(value: &self.previousTxnID)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.previousTransactionLedgerSequence)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.ownerNode)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.signerEntries)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.signerListID)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.signerQuorum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 1)
    }
    if !self.previousTxnID.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousTxnID, fieldNumber: 2)
    }
    if self.previousTransactionLedgerSequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.previousTransactionLedgerSequence, fieldNumber: 3)
    }
    if self.ownerNode != 0 {
      try visitor.visitSingularUInt64Field(value: self.ownerNode, fieldNumber: 4)
    }
    if !self.signerEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signerEntries, fieldNumber: 5)
    }
    if self.signerListID != 0 {
      try visitor.visitSingularUInt32Field(value: self.signerListID, fieldNumber: 6)
    }
    if self.signerQuorum != 0 {
      try visitor.visitSingularUInt32Field(value: self.signerQuorum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_SignerList, rhs: Rpc_V1_SignerList) -> Bool {
    if lhs.flags != rhs.flags {return false}
    if lhs.previousTxnID != rhs.previousTxnID {return false}
    if lhs.previousTransactionLedgerSequence != rhs.previousTransactionLedgerSequence {return false}
    if lhs.ownerNode != rhs.ownerNode {return false}
    if lhs.signerEntries != rhs.signerEntries {return false}
    if lhs.signerListID != rhs.signerListID {return false}
    if lhs.signerQuorum != rhs.signerQuorum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_SignerEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignerEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "signer_weight"),
  ]

  fileprivate class _StorageClass {
    var _account: Rpc_V1_AccountAddress? = nil
    var _signerWeight: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _signerWeight = source._signerWeight
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._signerWeight)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._signerWeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._signerWeight, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_SignerEntry, rhs: Rpc_V1_SignerEntry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._signerWeight != rhs_storage._signerWeight {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_AccountRoot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountRoot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "balance"),
    3: .same(proto: "sequence"),
    4: .same(proto: "flags"),
    5: .standard(proto: "owner_count"),
    6: .standard(proto: "previous_transaction_id"),
    7: .standard(proto: "previous_transaction_ledger_sequence"),
    8: .standard(proto: "account_transaction_id"),
    9: .same(proto: "domain"),
    10: .standard(proto: "email_hash"),
    11: .standard(proto: "message_key"),
    12: .standard(proto: "regular_key"),
    13: .standard(proto: "tick_size"),
    14: .standard(proto: "transfer_rate"),
  ]

  fileprivate class _StorageClass {
    var _account: Rpc_V1_AccountAddress? = nil
    var _balance: Rpc_V1_XRPDropsAmount? = nil
    var _sequence: UInt32 = 0
    var _flags: UInt32 = 0
    var _ownerCount: UInt32 = 0
    var _previousTransactionID: Data = SwiftProtobuf.Internal.emptyData
    var _previousTransactionLedgerSequence: UInt32 = 0
    var _accountTransactionID: Data = SwiftProtobuf.Internal.emptyData
    var _domain: Data = SwiftProtobuf.Internal.emptyData
    var _emailHash: Data = SwiftProtobuf.Internal.emptyData
    var _messageKey: Data = SwiftProtobuf.Internal.emptyData
    var _regularKey: String = String()
    var _tickSize: UInt32 = 0
    var _transferRate: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _balance = source._balance
      _sequence = source._sequence
      _flags = source._flags
      _ownerCount = source._ownerCount
      _previousTransactionID = source._previousTransactionID
      _previousTransactionLedgerSequence = source._previousTransactionLedgerSequence
      _accountTransactionID = source._accountTransactionID
      _domain = source._domain
      _emailHash = source._emailHash
      _messageKey = source._messageKey
      _regularKey = source._regularKey
      _tickSize = source._tickSize
      _transferRate = source._transferRate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._sequence)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._ownerCount)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._previousTransactionID)
        case 7: try decoder.decodeSingularUInt32Field(value: &_storage._previousTransactionLedgerSequence)
        case 8: try decoder.decodeSingularBytesField(value: &_storage._accountTransactionID)
        case 9: try decoder.decodeSingularBytesField(value: &_storage._domain)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._emailHash)
        case 11: try decoder.decodeSingularBytesField(value: &_storage._messageKey)
        case 12: try decoder.decodeSingularStringField(value: &_storage._regularKey)
        case 13: try decoder.decodeSingularUInt32Field(value: &_storage._tickSize)
        case 14: try decoder.decodeSingularUInt32Field(value: &_storage._transferRate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._sequence != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sequence, fieldNumber: 3)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 4)
      }
      if _storage._ownerCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ownerCount, fieldNumber: 5)
      }
      if !_storage._previousTransactionID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._previousTransactionID, fieldNumber: 6)
      }
      if _storage._previousTransactionLedgerSequence != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._previousTransactionLedgerSequence, fieldNumber: 7)
      }
      if !_storage._accountTransactionID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._accountTransactionID, fieldNumber: 8)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._domain, fieldNumber: 9)
      }
      if !_storage._emailHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._emailHash, fieldNumber: 10)
      }
      if !_storage._messageKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._messageKey, fieldNumber: 11)
      }
      if !_storage._regularKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._regularKey, fieldNumber: 12)
      }
      if _storage._tickSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._tickSize, fieldNumber: 13)
      }
      if _storage._transferRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._transferRate, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_AccountRoot, rhs: Rpc_V1_AccountRoot) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._sequence != rhs_storage._sequence {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._ownerCount != rhs_storage._ownerCount {return false}
        if _storage._previousTransactionID != rhs_storage._previousTransactionID {return false}
        if _storage._previousTransactionLedgerSequence != rhs_storage._previousTransactionLedgerSequence {return false}
        if _storage._accountTransactionID != rhs_storage._accountTransactionID {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._emailHash != rhs_storage._emailHash {return false}
        if _storage._messageKey != rhs_storage._messageKey {return false}
        if _storage._regularKey != rhs_storage._regularKey {return false}
        if _storage._tickSize != rhs_storage._tickSize {return false}
        if _storage._transferRate != rhs_storage._transferRate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_RippleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RippleState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    2: .same(proto: "flags"),
    3: .standard(proto: "low_limit"),
    4: .standard(proto: "high_limit"),
    5: .standard(proto: "low_node"),
    6: .standard(proto: "high_node"),
    7: .standard(proto: "low_quality_in"),
    8: .standard(proto: "low_quality_out"),
    9: .standard(proto: "high_quality_in"),
    10: .standard(proto: "high_quality_out"),
    11: .standard(proto: "previous_transaction_id"),
    12: .standard(proto: "previous_transaction_ledger_sequence"),
  ]

  fileprivate class _StorageClass {
    var _balance: Rpc_V1_CurrencyAmount? = nil
    var _flags: UInt32 = 0
    var _lowLimit: Rpc_V1_CurrencyAmount? = nil
    var _highLimit: Rpc_V1_CurrencyAmount? = nil
    var _lowNode: UInt64 = 0
    var _highNode: UInt64 = 0
    var _lowQualityIn: UInt32 = 0
    var _lowQualityOut: UInt32 = 0
    var _highQualityIn: UInt32 = 0
    var _highQualityOut: UInt32 = 0
    var _previousTransactionID: Data = SwiftProtobuf.Internal.emptyData
    var _previousTransactionLedgerSequence: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _balance = source._balance
      _flags = source._flags
      _lowLimit = source._lowLimit
      _highLimit = source._highLimit
      _lowNode = source._lowNode
      _highNode = source._highNode
      _lowQualityIn = source._lowQualityIn
      _lowQualityOut = source._lowQualityOut
      _highQualityIn = source._highQualityIn
      _highQualityOut = source._highQualityOut
      _previousTransactionID = source._previousTransactionID
      _previousTransactionLedgerSequence = source._previousTransactionLedgerSequence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lowLimit)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._highLimit)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._lowNode)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._highNode)
        case 7: try decoder.decodeSingularUInt32Field(value: &_storage._lowQualityIn)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._lowQualityOut)
        case 9: try decoder.decodeSingularUInt32Field(value: &_storage._highQualityIn)
        case 10: try decoder.decodeSingularUInt32Field(value: &_storage._highQualityOut)
        case 11: try decoder.decodeSingularBytesField(value: &_storage._previousTransactionID)
        case 12: try decoder.decodeSingularUInt32Field(value: &_storage._previousTransactionLedgerSequence)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 2)
      }
      if let v = _storage._lowLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._highLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._lowNode != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lowNode, fieldNumber: 5)
      }
      if _storage._highNode != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._highNode, fieldNumber: 6)
      }
      if _storage._lowQualityIn != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lowQualityIn, fieldNumber: 7)
      }
      if _storage._lowQualityOut != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lowQualityOut, fieldNumber: 8)
      }
      if _storage._highQualityIn != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._highQualityIn, fieldNumber: 9)
      }
      if _storage._highQualityOut != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._highQualityOut, fieldNumber: 10)
      }
      if !_storage._previousTransactionID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._previousTransactionID, fieldNumber: 11)
      }
      if _storage._previousTransactionLedgerSequence != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._previousTransactionLedgerSequence, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_RippleState, rhs: Rpc_V1_RippleState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._lowLimit != rhs_storage._lowLimit {return false}
        if _storage._highLimit != rhs_storage._highLimit {return false}
        if _storage._lowNode != rhs_storage._lowNode {return false}
        if _storage._highNode != rhs_storage._highNode {return false}
        if _storage._lowQualityIn != rhs_storage._lowQualityIn {return false}
        if _storage._lowQualityOut != rhs_storage._lowQualityOut {return false}
        if _storage._highQualityIn != rhs_storage._highQualityIn {return false}
        if _storage._highQualityOut != rhs_storage._highQualityOut {return false}
        if _storage._previousTransactionID != rhs_storage._previousTransactionID {return false}
        if _storage._previousTransactionLedgerSequence != rhs_storage._previousTransactionLedgerSequence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_Offer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Offer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "sequence"),
    3: .same(proto: "flags"),
    4: .standard(proto: "taker_pays"),
    5: .standard(proto: "taker_gets"),
    6: .standard(proto: "book_directory"),
    7: .standard(proto: "book_node"),
    8: .standard(proto: "owner_node"),
    9: .same(proto: "expiration"),
    10: .standard(proto: "previous_transaction_id"),
    11: .standard(proto: "previous_transaction_ledger_sequence"),
  ]

  fileprivate class _StorageClass {
    var _account: String = String()
    var _sequence: UInt32 = 0
    var _flags: UInt32 = 0
    var _takerPays: Rpc_V1_CurrencyAmount? = nil
    var _takerGets: Rpc_V1_CurrencyAmount? = nil
    var _bookDirectory: Data = SwiftProtobuf.Internal.emptyData
    var _bookNode: UInt64 = 0
    var _ownerNode: UInt64 = 0
    var _expiration: UInt32 = 0
    var _previousTransactionID: Data = SwiftProtobuf.Internal.emptyData
    var _previousTransactionLedgerSequence: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _sequence = source._sequence
      _flags = source._flags
      _takerPays = source._takerPays
      _takerGets = source._takerGets
      _bookDirectory = source._bookDirectory
      _bookNode = source._bookNode
      _ownerNode = source._ownerNode
      _expiration = source._expiration
      _previousTransactionID = source._previousTransactionID
      _previousTransactionLedgerSequence = source._previousTransactionLedgerSequence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._account)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._sequence)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._takerPays)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._takerGets)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._bookDirectory)
        case 7: try decoder.decodeSingularUInt64Field(value: &_storage._bookNode)
        case 8: try decoder.decodeSingularUInt64Field(value: &_storage._ownerNode)
        case 9: try decoder.decodeSingularUInt32Field(value: &_storage._expiration)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._previousTransactionID)
        case 11: try decoder.decodeSingularUInt32Field(value: &_storage._previousTransactionLedgerSequence)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._account.isEmpty {
        try visitor.visitSingularStringField(value: _storage._account, fieldNumber: 1)
      }
      if _storage._sequence != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sequence, fieldNumber: 2)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 3)
      }
      if let v = _storage._takerPays {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._takerGets {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._bookDirectory.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bookDirectory, fieldNumber: 6)
      }
      if _storage._bookNode != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bookNode, fieldNumber: 7)
      }
      if _storage._ownerNode != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._ownerNode, fieldNumber: 8)
      }
      if _storage._expiration != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._expiration, fieldNumber: 9)
      }
      if !_storage._previousTransactionID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._previousTransactionID, fieldNumber: 10)
      }
      if _storage._previousTransactionLedgerSequence != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._previousTransactionLedgerSequence, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_Offer, rhs: Rpc_V1_Offer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._sequence != rhs_storage._sequence {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._takerPays != rhs_storage._takerPays {return false}
        if _storage._takerGets != rhs_storage._takerGets {return false}
        if _storage._bookDirectory != rhs_storage._bookDirectory {return false}
        if _storage._bookNode != rhs_storage._bookNode {return false}
        if _storage._ownerNode != rhs_storage._ownerNode {return false}
        if _storage._expiration != rhs_storage._expiration {return false}
        if _storage._previousTransactionID != rhs_storage._previousTransactionID {return false}
        if _storage._previousTransactionLedgerSequence != rhs_storage._previousTransactionLedgerSequence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
