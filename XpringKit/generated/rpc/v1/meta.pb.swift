// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc/v1/meta.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Rpc_V1_Meta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// index in ledger
  public var transactionIndex: UInt64 {
    get {return _storage._transactionIndex}
    set {_uniqueStorage()._transactionIndex = newValue}
  }

  /// result code indicating whether the transaction succeeded or failed
  public var transactionResult: Rpc_V1_TransactionResult {
    get {return _storage._transactionResult ?? Rpc_V1_TransactionResult()}
    set {_uniqueStorage()._transactionResult = newValue}
  }
  /// Returns true if `transactionResult` has been explicitly set.
  public var hasTransactionResult: Bool {return _storage._transactionResult != nil}
  /// Clears the value of `transactionResult`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionResult() {_uniqueStorage()._transactionResult = nil}

  public var affectedNodes: [Rpc_V1_AffectedNode] {
    get {return _storage._affectedNodes}
    set {_uniqueStorage()._affectedNodes = newValue}
  }

  public var deliveredAmount: Rpc_V1_CurrencyAmount {
    get {return _storage._deliveredAmount ?? Rpc_V1_CurrencyAmount()}
    set {_uniqueStorage()._deliveredAmount = newValue}
  }
  /// Returns true if `deliveredAmount` has been explicitly set.
  public var hasDeliveredAmount: Bool {return _storage._deliveredAmount != nil}
  /// Clears the value of `deliveredAmount`. Subsequent reads from it will return its default value.
  public mutating func clearDeliveredAmount() {_uniqueStorage()._deliveredAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_TransactionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// category of the transaction result
  public var resultType: Rpc_V1_TransactionResult.ResultType = .unspecified

  /// full result string, i.e. tesSUCCESS
  public var result: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ResultType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Claimed cost only
    case tec // = 1

    /// Failure
    case tef // = 2

    /// Local error
    case tel // = 3

    /// Malformed transaction
    case tem // = 4

    /// Retry
    case ter // = 5

    /// Success
    case tes // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .tec
      case 2: self = .tef
      case 3: self = .tel
      case 4: self = .tem
      case 5: self = .ter
      case 6: self = .tes
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .tec: return 1
      case .tef: return 2
      case .tel: return 3
      case .tem: return 4
      case .ter: return 5
      case .tes: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Rpc_V1_TransactionResult.ResultType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Rpc_V1_TransactionResult.ResultType] = [
    .unspecified,
    .tec,
    .tef,
    .tel,
    .tem,
    .ter,
    .tes,
  ]
}

#endif  // swift(>=4.2)

public struct Rpc_V1_AffectedNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ledgerEntryType: Rpc_V1_LedgerEntryType {
    get {return _storage._ledgerEntryType}
    set {_uniqueStorage()._ledgerEntryType = newValue}
  }

  /// 32 bytes
  public var ledgerIndex: Data {
    get {return _storage._ledgerIndex}
    set {_uniqueStorage()._ledgerIndex = newValue}
  }

  public var node: OneOf_Node? {
    get {return _storage._node}
    set {_uniqueStorage()._node = newValue}
  }

  public var createdNode: Rpc_V1_CreatedNode {
    get {
      if case .createdNode(let v)? = _storage._node {return v}
      return Rpc_V1_CreatedNode()
    }
    set {_uniqueStorage()._node = .createdNode(newValue)}
  }

  public var deletedNode: Rpc_V1_DeletedNode {
    get {
      if case .deletedNode(let v)? = _storage._node {return v}
      return Rpc_V1_DeletedNode()
    }
    set {_uniqueStorage()._node = .deletedNode(newValue)}
  }

  public var modifiedNode: Rpc_V1_ModifiedNode {
    get {
      if case .modifiedNode(let v)? = _storage._node {return v}
      return Rpc_V1_ModifiedNode()
    }
    set {_uniqueStorage()._node = .modifiedNode(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Node: Equatable {
    case createdNode(Rpc_V1_CreatedNode)
    case deletedNode(Rpc_V1_DeletedNode)
    case modifiedNode(Rpc_V1_ModifiedNode)

  #if !swift(>=4.1)
    public static func ==(lhs: Rpc_V1_AffectedNode.OneOf_Node, rhs: Rpc_V1_AffectedNode.OneOf_Node) -> Bool {
      switch (lhs, rhs) {
      case (.createdNode(let l), .createdNode(let r)): return l == r
      case (.deletedNode(let l), .deletedNode(let r)): return l == r
      case (.modifiedNode(let l), .modifiedNode(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_CreatedNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newFields: Rpc_V1_LedgerObject {
    get {return _storage._newFields ?? Rpc_V1_LedgerObject()}
    set {_uniqueStorage()._newFields = newValue}
  }
  /// Returns true if `newFields` has been explicitly set.
  public var hasNewFields: Bool {return _storage._newFields != nil}
  /// Clears the value of `newFields`. Subsequent reads from it will return its default value.
  public mutating func clearNewFields() {_uniqueStorage()._newFields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_DeletedNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var finalFields: Rpc_V1_LedgerObject {
    get {return _storage._finalFields ?? Rpc_V1_LedgerObject()}
    set {_uniqueStorage()._finalFields = newValue}
  }
  /// Returns true if `finalFields` has been explicitly set.
  public var hasFinalFields: Bool {return _storage._finalFields != nil}
  /// Clears the value of `finalFields`. Subsequent reads from it will return its default value.
  public mutating func clearFinalFields() {_uniqueStorage()._finalFields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_V1_ModifiedNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var finalFields: Rpc_V1_LedgerObject {
    get {return _storage._finalFields ?? Rpc_V1_LedgerObject()}
    set {_uniqueStorage()._finalFields = newValue}
  }
  /// Returns true if `finalFields` has been explicitly set.
  public var hasFinalFields: Bool {return _storage._finalFields != nil}
  /// Clears the value of `finalFields`. Subsequent reads from it will return its default value.
  public mutating func clearFinalFields() {_uniqueStorage()._finalFields = nil}

  public var previousFields: Rpc_V1_LedgerObject {
    get {return _storage._previousFields ?? Rpc_V1_LedgerObject()}
    set {_uniqueStorage()._previousFields = newValue}
  }
  /// Returns true if `previousFields` has been explicitly set.
  public var hasPreviousFields: Bool {return _storage._previousFields != nil}
  /// Clears the value of `previousFields`. Subsequent reads from it will return its default value.
  public mutating func clearPreviousFields() {_uniqueStorage()._previousFields = nil}

  /// 32 bytes
  public var previousTransactionID: Data {
    get {return _storage._previousTransactionID}
    set {_uniqueStorage()._previousTransactionID = newValue}
  }

  public var previousTransactionLedgerSequence: UInt32 {
    get {return _storage._previousTransactionLedgerSequence}
    set {_uniqueStorage()._previousTransactionLedgerSequence = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rpc.v1"

extension Rpc_V1_Meta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Meta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_index"),
    2: .standard(proto: "transaction_result"),
    3: .standard(proto: "affected_nodes"),
    4: .standard(proto: "delivered_amount"),
  ]

  fileprivate class _StorageClass {
    var _transactionIndex: UInt64 = 0
    var _transactionResult: Rpc_V1_TransactionResult? = nil
    var _affectedNodes: [Rpc_V1_AffectedNode] = []
    var _deliveredAmount: Rpc_V1_CurrencyAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionIndex = source._transactionIndex
      _transactionResult = source._transactionResult
      _affectedNodes = source._affectedNodes
      _deliveredAmount = source._deliveredAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._transactionIndex)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._transactionResult)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._affectedNodes)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._deliveredAmount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._transactionIndex != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._transactionIndex, fieldNumber: 1)
      }
      if let v = _storage._transactionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._affectedNodes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._affectedNodes, fieldNumber: 3)
      }
      if let v = _storage._deliveredAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_Meta, rhs: Rpc_V1_Meta) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionIndex != rhs_storage._transactionIndex {return false}
        if _storage._transactionResult != rhs_storage._transactionResult {return false}
        if _storage._affectedNodes != rhs_storage._affectedNodes {return false}
        if _storage._deliveredAmount != rhs_storage._deliveredAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_TransactionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_type"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.resultType)
      case 2: try decoder.decodeSingularStringField(value: &self.result)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.resultType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resultType, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_TransactionResult, rhs: Rpc_V1_TransactionResult) -> Bool {
    if lhs.resultType != rhs.resultType {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_TransactionResult.ResultType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_TYPE_UNSPECIFIED"),
    1: .same(proto: "RESULT_TYPE_TEC"),
    2: .same(proto: "RESULT_TYPE_TEF"),
    3: .same(proto: "RESULT_TYPE_TEL"),
    4: .same(proto: "RESULT_TYPE_TEM"),
    5: .same(proto: "RESULT_TYPE_TER"),
    6: .same(proto: "RESULT_TYPE_TES"),
  ]
}

extension Rpc_V1_AffectedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AffectedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ledger_entry_type"),
    2: .standard(proto: "ledger_index"),
    3: .standard(proto: "created_node"),
    4: .standard(proto: "deleted_node"),
    5: .standard(proto: "modified_node"),
  ]

  fileprivate class _StorageClass {
    var _ledgerEntryType: Rpc_V1_LedgerEntryType = .unspecified
    var _ledgerIndex: Data = SwiftProtobuf.Internal.emptyData
    var _node: Rpc_V1_AffectedNode.OneOf_Node?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ledgerEntryType = source._ledgerEntryType
      _ledgerIndex = source._ledgerIndex
      _node = source._node
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._ledgerEntryType)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._ledgerIndex)
        case 3:
          var v: Rpc_V1_CreatedNode?
          if let current = _storage._node {
            try decoder.handleConflictingOneOf()
            if case .createdNode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._node = .createdNode(v)}
        case 4:
          var v: Rpc_V1_DeletedNode?
          if let current = _storage._node {
            try decoder.handleConflictingOneOf()
            if case .deletedNode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._node = .deletedNode(v)}
        case 5:
          var v: Rpc_V1_ModifiedNode?
          if let current = _storage._node {
            try decoder.handleConflictingOneOf()
            if case .modifiedNode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._node = .modifiedNode(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._ledgerEntryType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._ledgerEntryType, fieldNumber: 1)
      }
      if !_storage._ledgerIndex.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._ledgerIndex, fieldNumber: 2)
      }
      switch _storage._node {
      case .createdNode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .deletedNode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .modifiedNode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_AffectedNode, rhs: Rpc_V1_AffectedNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ledgerEntryType != rhs_storage._ledgerEntryType {return false}
        if _storage._ledgerIndex != rhs_storage._ledgerIndex {return false}
        if _storage._node != rhs_storage._node {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_CreatedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_fields"),
  ]

  fileprivate class _StorageClass {
    var _newFields: Rpc_V1_LedgerObject? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _newFields = source._newFields
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._newFields)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._newFields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_CreatedNode, rhs: Rpc_V1_CreatedNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._newFields != rhs_storage._newFields {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_DeletedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "final_fields"),
  ]

  fileprivate class _StorageClass {
    var _finalFields: Rpc_V1_LedgerObject? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _finalFields = source._finalFields
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._finalFields)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._finalFields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_DeletedNode, rhs: Rpc_V1_DeletedNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._finalFields != rhs_storage._finalFields {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_V1_ModifiedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModifiedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "final_fields"),
    2: .standard(proto: "previous_fields"),
    3: .standard(proto: "previous_transaction_id"),
    4: .standard(proto: "previous_transaction_ledger_sequence"),
  ]

  fileprivate class _StorageClass {
    var _finalFields: Rpc_V1_LedgerObject? = nil
    var _previousFields: Rpc_V1_LedgerObject? = nil
    var _previousTransactionID: Data = SwiftProtobuf.Internal.emptyData
    var _previousTransactionLedgerSequence: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _finalFields = source._finalFields
      _previousFields = source._previousFields
      _previousTransactionID = source._previousTransactionID
      _previousTransactionLedgerSequence = source._previousTransactionLedgerSequence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._finalFields)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._previousFields)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._previousTransactionID)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._previousTransactionLedgerSequence)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._finalFields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._previousFields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._previousTransactionID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._previousTransactionID, fieldNumber: 3)
      }
      if _storage._previousTransactionLedgerSequence != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._previousTransactionLedgerSequence, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_V1_ModifiedNode, rhs: Rpc_V1_ModifiedNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._finalFields != rhs_storage._finalFields {return false}
        if _storage._previousFields != rhs_storage._previousFields {return false}
        if _storage._previousTransactionID != rhs_storage._previousTransactionID {return false}
        if _storage._previousTransactionLedgerSequence != rhs_storage._previousTransactionLedgerSequence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
