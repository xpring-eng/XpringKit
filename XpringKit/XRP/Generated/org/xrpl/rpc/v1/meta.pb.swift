// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: org/xrpl/rpc/v1/meta.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Next field: 5
public struct Org_Xrpl_Rpc_V1_Meta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// index in ledger
  public var transactionIndex: UInt64 = 0

  /// result code indicating whether the transaction succeeded or failed
  public var transactionResult: Org_Xrpl_Rpc_V1_TransactionResult {
    get {return _transactionResult ?? Org_Xrpl_Rpc_V1_TransactionResult()}
    set {_transactionResult = newValue}
  }
  /// Returns true if `transactionResult` has been explicitly set.
  public var hasTransactionResult: Bool {return self._transactionResult != nil}
  /// Clears the value of `transactionResult`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionResult() {self._transactionResult = nil}

  public var affectedNodes: [Org_Xrpl_Rpc_V1_AffectedNode] = []

  public var deliveredAmount: Org_Xrpl_Rpc_V1_DeliveredAmount {
    get {return _deliveredAmount ?? Org_Xrpl_Rpc_V1_DeliveredAmount()}
    set {_deliveredAmount = newValue}
  }
  /// Returns true if `deliveredAmount` has been explicitly set.
  public var hasDeliveredAmount: Bool {return self._deliveredAmount != nil}
  /// Clears the value of `deliveredAmount`. Subsequent reads from it will return its default value.
  public mutating func clearDeliveredAmount() {self._deliveredAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transactionResult: Org_Xrpl_Rpc_V1_TransactionResult? = nil
  fileprivate var _deliveredAmount: Org_Xrpl_Rpc_V1_DeliveredAmount? = nil
}

/// Next field: 3
public struct Org_Xrpl_Rpc_V1_TransactionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// category of the transaction result
  public var resultType: Org_Xrpl_Rpc_V1_TransactionResult.ResultType = .unspecified

  /// full result string, i.e. tesSUCCESS
  public var result: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Next field: 7
  public enum ResultType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Claimed cost only
    case tec // = 1

    /// Failure
    case tef // = 2

    /// Local error
    case tel // = 3

    /// Malformed transaction
    case tem // = 4

    /// Retry
    case ter // = 5

    /// Success
    case tes // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .tec
      case 2: self = .tef
      case 3: self = .tel
      case 4: self = .tem
      case 5: self = .ter
      case 6: self = .tes
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .tec: return 1
      case .tef: return 2
      case .tel: return 3
      case .tem: return 4
      case .ter: return 5
      case .tes: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Org_Xrpl_Rpc_V1_TransactionResult.ResultType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Org_Xrpl_Rpc_V1_TransactionResult.ResultType] = [
    .unspecified,
    .tec,
    .tef,
    .tel,
    .tem,
    .ter,
    .tes,
  ]
}

#endif  // swift(>=4.2)

/// Next field: 6
public struct Org_Xrpl_Rpc_V1_AffectedNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ledgerEntryType: Org_Xrpl_Rpc_V1_LedgerEntryType = .unspecified

  /// 32 bytes
  public var ledgerIndex: Data = SwiftProtobuf.Internal.emptyData

  public var node: Org_Xrpl_Rpc_V1_AffectedNode.OneOf_Node? = nil

  public var createdNode: Org_Xrpl_Rpc_V1_CreatedNode {
    get {
      if case .createdNode(let v)? = node {return v}
      return Org_Xrpl_Rpc_V1_CreatedNode()
    }
    set {node = .createdNode(newValue)}
  }

  public var deletedNode: Org_Xrpl_Rpc_V1_DeletedNode {
    get {
      if case .deletedNode(let v)? = node {return v}
      return Org_Xrpl_Rpc_V1_DeletedNode()
    }
    set {node = .deletedNode(newValue)}
  }

  public var modifiedNode: Org_Xrpl_Rpc_V1_ModifiedNode {
    get {
      if case .modifiedNode(let v)? = node {return v}
      return Org_Xrpl_Rpc_V1_ModifiedNode()
    }
    set {node = .modifiedNode(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Node: Equatable {
    case createdNode(Org_Xrpl_Rpc_V1_CreatedNode)
    case deletedNode(Org_Xrpl_Rpc_V1_DeletedNode)
    case modifiedNode(Org_Xrpl_Rpc_V1_ModifiedNode)

  #if !swift(>=4.1)
    public static func ==(lhs: Org_Xrpl_Rpc_V1_AffectedNode.OneOf_Node, rhs: Org_Xrpl_Rpc_V1_AffectedNode.OneOf_Node) -> Bool {
      switch (lhs, rhs) {
      case (.createdNode(let l), .createdNode(let r)): return l == r
      case (.deletedNode(let l), .deletedNode(let r)): return l == r
      case (.modifiedNode(let l), .modifiedNode(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Next field: 2
public struct Org_Xrpl_Rpc_V1_CreatedNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newFields: Org_Xrpl_Rpc_V1_LedgerObject {
    get {return _newFields ?? Org_Xrpl_Rpc_V1_LedgerObject()}
    set {_newFields = newValue}
  }
  /// Returns true if `newFields` has been explicitly set.
  public var hasNewFields: Bool {return self._newFields != nil}
  /// Clears the value of `newFields`. Subsequent reads from it will return its default value.
  public mutating func clearNewFields() {self._newFields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _newFields: Org_Xrpl_Rpc_V1_LedgerObject? = nil
}

/// Next field: 2
public struct Org_Xrpl_Rpc_V1_DeletedNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var finalFields: Org_Xrpl_Rpc_V1_LedgerObject {
    get {return _finalFields ?? Org_Xrpl_Rpc_V1_LedgerObject()}
    set {_finalFields = newValue}
  }
  /// Returns true if `finalFields` has been explicitly set.
  public var hasFinalFields: Bool {return self._finalFields != nil}
  /// Clears the value of `finalFields`. Subsequent reads from it will return its default value.
  public mutating func clearFinalFields() {self._finalFields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _finalFields: Org_Xrpl_Rpc_V1_LedgerObject? = nil
}

/// Next field: 5
public struct Org_Xrpl_Rpc_V1_ModifiedNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var finalFields: Org_Xrpl_Rpc_V1_LedgerObject {
    get {return _finalFields ?? Org_Xrpl_Rpc_V1_LedgerObject()}
    set {_finalFields = newValue}
  }
  /// Returns true if `finalFields` has been explicitly set.
  public var hasFinalFields: Bool {return self._finalFields != nil}
  /// Clears the value of `finalFields`. Subsequent reads from it will return its default value.
  public mutating func clearFinalFields() {self._finalFields = nil}

  public var previousFields: Org_Xrpl_Rpc_V1_LedgerObject {
    get {return _previousFields ?? Org_Xrpl_Rpc_V1_LedgerObject()}
    set {_previousFields = newValue}
  }
  /// Returns true if `previousFields` has been explicitly set.
  public var hasPreviousFields: Bool {return self._previousFields != nil}
  /// Clears the value of `previousFields`. Subsequent reads from it will return its default value.
  public mutating func clearPreviousFields() {self._previousFields = nil}

  public var previousTransactionID: Org_Xrpl_Rpc_V1_PreviousTransactionID {
    get {return _previousTransactionID ?? Org_Xrpl_Rpc_V1_PreviousTransactionID()}
    set {_previousTransactionID = newValue}
  }
  /// Returns true if `previousTransactionID` has been explicitly set.
  public var hasPreviousTransactionID: Bool {return self._previousTransactionID != nil}
  /// Clears the value of `previousTransactionID`. Subsequent reads from it will return its default value.
  public mutating func clearPreviousTransactionID() {self._previousTransactionID = nil}

  public var previousTransactionLedgerSequence: Org_Xrpl_Rpc_V1_PreviousTransactionLedgerSequence {
    get {return _previousTransactionLedgerSequence ?? Org_Xrpl_Rpc_V1_PreviousTransactionLedgerSequence()}
    set {_previousTransactionLedgerSequence = newValue}
  }
  /// Returns true if `previousTransactionLedgerSequence` has been explicitly set.
  public var hasPreviousTransactionLedgerSequence: Bool {return self._previousTransactionLedgerSequence != nil}
  /// Clears the value of `previousTransactionLedgerSequence`. Subsequent reads from it will return its default value.
  public mutating func clearPreviousTransactionLedgerSequence() {self._previousTransactionLedgerSequence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _finalFields: Org_Xrpl_Rpc_V1_LedgerObject? = nil
  fileprivate var _previousFields: Org_Xrpl_Rpc_V1_LedgerObject? = nil
  fileprivate var _previousTransactionID: Org_Xrpl_Rpc_V1_PreviousTransactionID? = nil
  fileprivate var _previousTransactionLedgerSequence: Org_Xrpl_Rpc_V1_PreviousTransactionLedgerSequence? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "org.xrpl.rpc.v1"

extension Org_Xrpl_Rpc_V1_Meta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Meta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_index"),
    2: .standard(proto: "transaction_result"),
    3: .standard(proto: "affected_nodes"),
    4: .standard(proto: "delivered_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.transactionIndex)
      case 2: try decoder.decodeSingularMessageField(value: &self._transactionResult)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.affectedNodes)
      case 4: try decoder.decodeSingularMessageField(value: &self._deliveredAmount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transactionIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.transactionIndex, fieldNumber: 1)
    }
    if let v = self._transactionResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.affectedNodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.affectedNodes, fieldNumber: 3)
    }
    if let v = self._deliveredAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_Meta, rhs: Org_Xrpl_Rpc_V1_Meta) -> Bool {
    if lhs.transactionIndex != rhs.transactionIndex {return false}
    if lhs._transactionResult != rhs._transactionResult {return false}
    if lhs.affectedNodes != rhs.affectedNodes {return false}
    if lhs._deliveredAmount != rhs._deliveredAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_TransactionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_type"),
    2: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.resultType)
      case 2: try decoder.decodeSingularStringField(value: &self.result)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.resultType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resultType, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_TransactionResult, rhs: Org_Xrpl_Rpc_V1_TransactionResult) -> Bool {
    if lhs.resultType != rhs.resultType {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_TransactionResult.ResultType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_TYPE_UNSPECIFIED"),
    1: .same(proto: "RESULT_TYPE_TEC"),
    2: .same(proto: "RESULT_TYPE_TEF"),
    3: .same(proto: "RESULT_TYPE_TEL"),
    4: .same(proto: "RESULT_TYPE_TEM"),
    5: .same(proto: "RESULT_TYPE_TER"),
    6: .same(proto: "RESULT_TYPE_TES"),
  ]
}

extension Org_Xrpl_Rpc_V1_AffectedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AffectedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ledger_entry_type"),
    2: .standard(proto: "ledger_index"),
    3: .standard(proto: "created_node"),
    4: .standard(proto: "deleted_node"),
    5: .standard(proto: "modified_node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.ledgerEntryType)
      case 2: try decoder.decodeSingularBytesField(value: &self.ledgerIndex)
      case 3:
        var v: Org_Xrpl_Rpc_V1_CreatedNode?
        if let current = self.node {
          try decoder.handleConflictingOneOf()
          if case .createdNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.node = .createdNode(v)}
      case 4:
        var v: Org_Xrpl_Rpc_V1_DeletedNode?
        if let current = self.node {
          try decoder.handleConflictingOneOf()
          if case .deletedNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.node = .deletedNode(v)}
      case 5:
        var v: Org_Xrpl_Rpc_V1_ModifiedNode?
        if let current = self.node {
          try decoder.handleConflictingOneOf()
          if case .modifiedNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.node = .modifiedNode(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ledgerEntryType != .unspecified {
      try visitor.visitSingularEnumField(value: self.ledgerEntryType, fieldNumber: 1)
    }
    if !self.ledgerIndex.isEmpty {
      try visitor.visitSingularBytesField(value: self.ledgerIndex, fieldNumber: 2)
    }
    switch self.node {
    case .createdNode(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .deletedNode(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .modifiedNode(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_AffectedNode, rhs: Org_Xrpl_Rpc_V1_AffectedNode) -> Bool {
    if lhs.ledgerEntryType != rhs.ledgerEntryType {return false}
    if lhs.ledgerIndex != rhs.ledgerIndex {return false}
    if lhs.node != rhs.node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_CreatedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._newFields)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._newFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_CreatedNode, rhs: Org_Xrpl_Rpc_V1_CreatedNode) -> Bool {
    if lhs._newFields != rhs._newFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_DeletedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "final_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._finalFields)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._finalFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_DeletedNode, rhs: Org_Xrpl_Rpc_V1_DeletedNode) -> Bool {
    if lhs._finalFields != rhs._finalFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_ModifiedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModifiedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "final_fields"),
    2: .standard(proto: "previous_fields"),
    3: .standard(proto: "previous_transaction_id"),
    4: .standard(proto: "previous_transaction_ledger_sequence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._finalFields)
      case 2: try decoder.decodeSingularMessageField(value: &self._previousFields)
      case 3: try decoder.decodeSingularMessageField(value: &self._previousTransactionID)
      case 4: try decoder.decodeSingularMessageField(value: &self._previousTransactionLedgerSequence)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._finalFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._previousFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._previousTransactionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._previousTransactionLedgerSequence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_ModifiedNode, rhs: Org_Xrpl_Rpc_V1_ModifiedNode) -> Bool {
    if lhs._finalFields != rhs._finalFields {return false}
    if lhs._previousFields != rhs._previousFields {return false}
    if lhs._previousTransactionID != rhs._previousTransactionID {return false}
    if lhs._previousTransactionLedgerSequence != rhs._previousTransactionLedgerSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
