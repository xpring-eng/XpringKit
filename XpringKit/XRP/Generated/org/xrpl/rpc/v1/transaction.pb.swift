// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: org/xrpl/rpc/v1/transaction.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A message encompassing all transaction types
/// Next field: 30
public struct Org_Xrpl_Rpc_V1_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Org_Xrpl_Rpc_V1_Account {
    get {return _storage._account ?? Org_Xrpl_Rpc_V1_Account()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  public var fee: Org_Xrpl_Rpc_V1_XRPDropsAmount {
    get {return _storage._fee ?? Org_Xrpl_Rpc_V1_XRPDropsAmount()}
    set {_uniqueStorage()._fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  public var hasFee: Bool {return _storage._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  public mutating func clearFee() {_uniqueStorage()._fee = nil}

  public var sequence: Org_Xrpl_Rpc_V1_Sequence {
    get {return _storage._sequence ?? Org_Xrpl_Rpc_V1_Sequence()}
    set {_uniqueStorage()._sequence = newValue}
  }
  /// Returns true if `sequence` has been explicitly set.
  public var hasSequence: Bool {return _storage._sequence != nil}
  /// Clears the value of `sequence`. Subsequent reads from it will return its default value.
  public mutating func clearSequence() {_uniqueStorage()._sequence = nil}

  /// Data specific to the type of transaction
  public var transactionData: OneOf_TransactionData? {
    get {return _storage._transactionData}
    set {_uniqueStorage()._transactionData = newValue}
  }

  public var payment: Org_Xrpl_Rpc_V1_Payment {
    get {
      if case .payment(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_Payment()
    }
    set {_uniqueStorage()._transactionData = .payment(newValue)}
  }

  public var accountSet: Org_Xrpl_Rpc_V1_AccountSet {
    get {
      if case .accountSet(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_AccountSet()
    }
    set {_uniqueStorage()._transactionData = .accountSet(newValue)}
  }

  public var accountDelete: Org_Xrpl_Rpc_V1_AccountDelete {
    get {
      if case .accountDelete(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_AccountDelete()
    }
    set {_uniqueStorage()._transactionData = .accountDelete(newValue)}
  }

  public var checkCancel: Org_Xrpl_Rpc_V1_CheckCancel {
    get {
      if case .checkCancel(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_CheckCancel()
    }
    set {_uniqueStorage()._transactionData = .checkCancel(newValue)}
  }

  public var checkCash: Org_Xrpl_Rpc_V1_CheckCash {
    get {
      if case .checkCash(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_CheckCash()
    }
    set {_uniqueStorage()._transactionData = .checkCash(newValue)}
  }

  public var checkCreate: Org_Xrpl_Rpc_V1_CheckCreate {
    get {
      if case .checkCreate(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_CheckCreate()
    }
    set {_uniqueStorage()._transactionData = .checkCreate(newValue)}
  }

  public var depositPreauth: Org_Xrpl_Rpc_V1_DepositPreauth {
    get {
      if case .depositPreauth(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_DepositPreauth()
    }
    set {_uniqueStorage()._transactionData = .depositPreauth(newValue)}
  }

  public var escrowCancel: Org_Xrpl_Rpc_V1_EscrowCancel {
    get {
      if case .escrowCancel(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_EscrowCancel()
    }
    set {_uniqueStorage()._transactionData = .escrowCancel(newValue)}
  }

  public var escrowCreate: Org_Xrpl_Rpc_V1_EscrowCreate {
    get {
      if case .escrowCreate(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_EscrowCreate()
    }
    set {_uniqueStorage()._transactionData = .escrowCreate(newValue)}
  }

  public var escrowFinish: Org_Xrpl_Rpc_V1_EscrowFinish {
    get {
      if case .escrowFinish(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_EscrowFinish()
    }
    set {_uniqueStorage()._transactionData = .escrowFinish(newValue)}
  }

  public var offerCancel: Org_Xrpl_Rpc_V1_OfferCancel {
    get {
      if case .offerCancel(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_OfferCancel()
    }
    set {_uniqueStorage()._transactionData = .offerCancel(newValue)}
  }

  public var offerCreate: Org_Xrpl_Rpc_V1_OfferCreate {
    get {
      if case .offerCreate(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_OfferCreate()
    }
    set {_uniqueStorage()._transactionData = .offerCreate(newValue)}
  }

  public var paymentChannelClaim: Org_Xrpl_Rpc_V1_PaymentChannelClaim {
    get {
      if case .paymentChannelClaim(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_PaymentChannelClaim()
    }
    set {_uniqueStorage()._transactionData = .paymentChannelClaim(newValue)}
  }

  public var paymentChannelCreate: Org_Xrpl_Rpc_V1_PaymentChannelCreate {
    get {
      if case .paymentChannelCreate(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_PaymentChannelCreate()
    }
    set {_uniqueStorage()._transactionData = .paymentChannelCreate(newValue)}
  }

  public var paymentChannelFund: Org_Xrpl_Rpc_V1_PaymentChannelFund {
    get {
      if case .paymentChannelFund(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_PaymentChannelFund()
    }
    set {_uniqueStorage()._transactionData = .paymentChannelFund(newValue)}
  }

  public var setRegularKey: Org_Xrpl_Rpc_V1_SetRegularKey {
    get {
      if case .setRegularKey(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_SetRegularKey()
    }
    set {_uniqueStorage()._transactionData = .setRegularKey(newValue)}
  }

  public var signerListSet: Org_Xrpl_Rpc_V1_SignerListSet {
    get {
      if case .signerListSet(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_SignerListSet()
    }
    set {_uniqueStorage()._transactionData = .signerListSet(newValue)}
  }

  public var trustSet: Org_Xrpl_Rpc_V1_TrustSet {
    get {
      if case .trustSet(let v)? = _storage._transactionData {return v}
      return Org_Xrpl_Rpc_V1_TrustSet()
    }
    set {_uniqueStorage()._transactionData = .trustSet(newValue)}
  }

  public var signingPublicKey: Org_Xrpl_Rpc_V1_SigningPublicKey {
    get {return _storage._signingPublicKey ?? Org_Xrpl_Rpc_V1_SigningPublicKey()}
    set {_uniqueStorage()._signingPublicKey = newValue}
  }
  /// Returns true if `signingPublicKey` has been explicitly set.
  public var hasSigningPublicKey: Bool {return _storage._signingPublicKey != nil}
  /// Clears the value of `signingPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearSigningPublicKey() {_uniqueStorage()._signingPublicKey = nil}

  public var transactionSignature: Org_Xrpl_Rpc_V1_TransactionSignature {
    get {return _storage._transactionSignature ?? Org_Xrpl_Rpc_V1_TransactionSignature()}
    set {_uniqueStorage()._transactionSignature = newValue}
  }
  /// Returns true if `transactionSignature` has been explicitly set.
  public var hasTransactionSignature: Bool {return _storage._transactionSignature != nil}
  /// Clears the value of `transactionSignature`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionSignature() {_uniqueStorage()._transactionSignature = nil}

  public var flags: Org_Xrpl_Rpc_V1_Flags {
    get {return _storage._flags ?? Org_Xrpl_Rpc_V1_Flags()}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  public var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  public mutating func clearFlags() {_uniqueStorage()._flags = nil}

  public var lastLedgerSequence: Org_Xrpl_Rpc_V1_LastLedgerSequence {
    get {return _storage._lastLedgerSequence ?? Org_Xrpl_Rpc_V1_LastLedgerSequence()}
    set {_uniqueStorage()._lastLedgerSequence = newValue}
  }
  /// Returns true if `lastLedgerSequence` has been explicitly set.
  public var hasLastLedgerSequence: Bool {return _storage._lastLedgerSequence != nil}
  /// Clears the value of `lastLedgerSequence`. Subsequent reads from it will return its default value.
  public mutating func clearLastLedgerSequence() {_uniqueStorage()._lastLedgerSequence = nil}

  public var sourceTag: Org_Xrpl_Rpc_V1_SourceTag {
    get {return _storage._sourceTag ?? Org_Xrpl_Rpc_V1_SourceTag()}
    set {_uniqueStorage()._sourceTag = newValue}
  }
  /// Returns true if `sourceTag` has been explicitly set.
  public var hasSourceTag: Bool {return _storage._sourceTag != nil}
  /// Clears the value of `sourceTag`. Subsequent reads from it will return its default value.
  public mutating func clearSourceTag() {_uniqueStorage()._sourceTag = nil}

  public var memos: [Org_Xrpl_Rpc_V1_Memo] {
    get {return _storage._memos}
    set {_uniqueStorage()._memos = newValue}
  }

  public var signers: [Org_Xrpl_Rpc_V1_Signer] {
    get {return _storage._signers}
    set {_uniqueStorage()._signers = newValue}
  }

  public var accountTransactionID: Org_Xrpl_Rpc_V1_AccountTransactionID {
    get {return _storage._accountTransactionID ?? Org_Xrpl_Rpc_V1_AccountTransactionID()}
    set {_uniqueStorage()._accountTransactionID = newValue}
  }
  /// Returns true if `accountTransactionID` has been explicitly set.
  public var hasAccountTransactionID: Bool {return _storage._accountTransactionID != nil}
  /// Clears the value of `accountTransactionID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountTransactionID() {_uniqueStorage()._accountTransactionID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Data specific to the type of transaction
  public enum OneOf_TransactionData: Equatable {
    case payment(Org_Xrpl_Rpc_V1_Payment)
    case accountSet(Org_Xrpl_Rpc_V1_AccountSet)
    case accountDelete(Org_Xrpl_Rpc_V1_AccountDelete)
    case checkCancel(Org_Xrpl_Rpc_V1_CheckCancel)
    case checkCash(Org_Xrpl_Rpc_V1_CheckCash)
    case checkCreate(Org_Xrpl_Rpc_V1_CheckCreate)
    case depositPreauth(Org_Xrpl_Rpc_V1_DepositPreauth)
    case escrowCancel(Org_Xrpl_Rpc_V1_EscrowCancel)
    case escrowCreate(Org_Xrpl_Rpc_V1_EscrowCreate)
    case escrowFinish(Org_Xrpl_Rpc_V1_EscrowFinish)
    case offerCancel(Org_Xrpl_Rpc_V1_OfferCancel)
    case offerCreate(Org_Xrpl_Rpc_V1_OfferCreate)
    case paymentChannelClaim(Org_Xrpl_Rpc_V1_PaymentChannelClaim)
    case paymentChannelCreate(Org_Xrpl_Rpc_V1_PaymentChannelCreate)
    case paymentChannelFund(Org_Xrpl_Rpc_V1_PaymentChannelFund)
    case setRegularKey(Org_Xrpl_Rpc_V1_SetRegularKey)
    case signerListSet(Org_Xrpl_Rpc_V1_SignerListSet)
    case trustSet(Org_Xrpl_Rpc_V1_TrustSet)

  #if !swift(>=4.1)
    public static func ==(lhs: Org_Xrpl_Rpc_V1_Transaction.OneOf_TransactionData, rhs: Org_Xrpl_Rpc_V1_Transaction.OneOf_TransactionData) -> Bool {
      switch (lhs, rhs) {
      case (.payment(let l), .payment(let r)): return l == r
      case (.accountSet(let l), .accountSet(let r)): return l == r
      case (.accountDelete(let l), .accountDelete(let r)): return l == r
      case (.checkCancel(let l), .checkCancel(let r)): return l == r
      case (.checkCash(let l), .checkCash(let r)): return l == r
      case (.checkCreate(let l), .checkCreate(let r)): return l == r
      case (.depositPreauth(let l), .depositPreauth(let r)): return l == r
      case (.escrowCancel(let l), .escrowCancel(let r)): return l == r
      case (.escrowCreate(let l), .escrowCreate(let r)): return l == r
      case (.escrowFinish(let l), .escrowFinish(let r)): return l == r
      case (.offerCancel(let l), .offerCancel(let r)): return l == r
      case (.offerCreate(let l), .offerCreate(let r)): return l == r
      case (.paymentChannelClaim(let l), .paymentChannelClaim(let r)): return l == r
      case (.paymentChannelCreate(let l), .paymentChannelCreate(let r)): return l == r
      case (.paymentChannelFund(let l), .paymentChannelFund(let r)): return l == r
      case (.setRegularKey(let l), .setRegularKey(let r)): return l == r
      case (.signerListSet(let l), .signerListSet(let r)): return l == r
      case (.trustSet(let l), .trustSet(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 4
public struct Org_Xrpl_Rpc_V1_Memo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var memoData: Org_Xrpl_Rpc_V1_MemoData {
    get {return _storage._memoData ?? Org_Xrpl_Rpc_V1_MemoData()}
    set {_uniqueStorage()._memoData = newValue}
  }
  /// Returns true if `memoData` has been explicitly set.
  public var hasMemoData: Bool {return _storage._memoData != nil}
  /// Clears the value of `memoData`. Subsequent reads from it will return its default value.
  public mutating func clearMemoData() {_uniqueStorage()._memoData = nil}

  public var memoFormat: Org_Xrpl_Rpc_V1_MemoFormat {
    get {return _storage._memoFormat ?? Org_Xrpl_Rpc_V1_MemoFormat()}
    set {_uniqueStorage()._memoFormat = newValue}
  }
  /// Returns true if `memoFormat` has been explicitly set.
  public var hasMemoFormat: Bool {return _storage._memoFormat != nil}
  /// Clears the value of `memoFormat`. Subsequent reads from it will return its default value.
  public mutating func clearMemoFormat() {_uniqueStorage()._memoFormat = nil}

  public var memoType: Org_Xrpl_Rpc_V1_MemoType {
    get {return _storage._memoType ?? Org_Xrpl_Rpc_V1_MemoType()}
    set {_uniqueStorage()._memoType = newValue}
  }
  /// Returns true if `memoType` has been explicitly set.
  public var hasMemoType: Bool {return _storage._memoType != nil}
  /// Clears the value of `memoType`. Subsequent reads from it will return its default value.
  public mutating func clearMemoType() {_uniqueStorage()._memoType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 4
public struct Org_Xrpl_Rpc_V1_Signer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Org_Xrpl_Rpc_V1_Account {
    get {return _storage._account ?? Org_Xrpl_Rpc_V1_Account()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  public var transactionSignature: Org_Xrpl_Rpc_V1_TransactionSignature {
    get {return _storage._transactionSignature ?? Org_Xrpl_Rpc_V1_TransactionSignature()}
    set {_uniqueStorage()._transactionSignature = newValue}
  }
  /// Returns true if `transactionSignature` has been explicitly set.
  public var hasTransactionSignature: Bool {return _storage._transactionSignature != nil}
  /// Clears the value of `transactionSignature`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionSignature() {_uniqueStorage()._transactionSignature = nil}

  public var signingPublicKey: Org_Xrpl_Rpc_V1_SigningPublicKey {
    get {return _storage._signingPublicKey ?? Org_Xrpl_Rpc_V1_SigningPublicKey()}
    set {_uniqueStorage()._signingPublicKey = newValue}
  }
  /// Returns true if `signingPublicKey` has been explicitly set.
  public var hasSigningPublicKey: Bool {return _storage._signingPublicKey != nil}
  /// Clears the value of `signingPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearSigningPublicKey() {_uniqueStorage()._signingPublicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 8
public struct Org_Xrpl_Rpc_V1_AccountSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clearFlag_p: Org_Xrpl_Rpc_V1_ClearFlag {
    get {return _storage._clearFlag_p ?? Org_Xrpl_Rpc_V1_ClearFlag()}
    set {_uniqueStorage()._clearFlag_p = newValue}
  }
  /// Returns true if `clearFlag_p` has been explicitly set.
  public var hasClearFlag_p: Bool {return _storage._clearFlag_p != nil}
  /// Clears the value of `clearFlag_p`. Subsequent reads from it will return its default value.
  public mutating func clearClearFlag_p() {_uniqueStorage()._clearFlag_p = nil}

  public var domain: Org_Xrpl_Rpc_V1_Domain {
    get {return _storage._domain ?? Org_Xrpl_Rpc_V1_Domain()}
    set {_uniqueStorage()._domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  public var hasDomain: Bool {return _storage._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  public mutating func clearDomain() {_uniqueStorage()._domain = nil}

  public var emailHash: Org_Xrpl_Rpc_V1_EmailHash {
    get {return _storage._emailHash ?? Org_Xrpl_Rpc_V1_EmailHash()}
    set {_uniqueStorage()._emailHash = newValue}
  }
  /// Returns true if `emailHash` has been explicitly set.
  public var hasEmailHash: Bool {return _storage._emailHash != nil}
  /// Clears the value of `emailHash`. Subsequent reads from it will return its default value.
  public mutating func clearEmailHash() {_uniqueStorage()._emailHash = nil}

  public var messageKey: Org_Xrpl_Rpc_V1_MessageKey {
    get {return _storage._messageKey ?? Org_Xrpl_Rpc_V1_MessageKey()}
    set {_uniqueStorage()._messageKey = newValue}
  }
  /// Returns true if `messageKey` has been explicitly set.
  public var hasMessageKey: Bool {return _storage._messageKey != nil}
  /// Clears the value of `messageKey`. Subsequent reads from it will return its default value.
  public mutating func clearMessageKey() {_uniqueStorage()._messageKey = nil}

  public var setFlag: Org_Xrpl_Rpc_V1_SetFlag {
    get {return _storage._setFlag ?? Org_Xrpl_Rpc_V1_SetFlag()}
    set {_uniqueStorage()._setFlag = newValue}
  }
  /// Returns true if `setFlag` has been explicitly set.
  public var hasSetFlag: Bool {return _storage._setFlag != nil}
  /// Clears the value of `setFlag`. Subsequent reads from it will return its default value.
  public mutating func clearSetFlag() {_uniqueStorage()._setFlag = nil}

  public var transferRate: Org_Xrpl_Rpc_V1_TransferRate {
    get {return _storage._transferRate ?? Org_Xrpl_Rpc_V1_TransferRate()}
    set {_uniqueStorage()._transferRate = newValue}
  }
  /// Returns true if `transferRate` has been explicitly set.
  public var hasTransferRate: Bool {return _storage._transferRate != nil}
  /// Clears the value of `transferRate`. Subsequent reads from it will return its default value.
  public mutating func clearTransferRate() {_uniqueStorage()._transferRate = nil}

  public var tickSize: Org_Xrpl_Rpc_V1_TickSize {
    get {return _storage._tickSize ?? Org_Xrpl_Rpc_V1_TickSize()}
    set {_uniqueStorage()._tickSize = newValue}
  }
  /// Returns true if `tickSize` has been explicitly set.
  public var hasTickSize: Bool {return _storage._tickSize != nil}
  /// Clears the value of `tickSize`. Subsequent reads from it will return its default value.
  public mutating func clearTickSize() {_uniqueStorage()._tickSize = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 3
public struct Org_Xrpl_Rpc_V1_AccountDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var destination: Org_Xrpl_Rpc_V1_Destination {
    get {return _storage._destination ?? Org_Xrpl_Rpc_V1_Destination()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  public var destinationTag: Org_Xrpl_Rpc_V1_DestinationTag {
    get {return _storage._destinationTag ?? Org_Xrpl_Rpc_V1_DestinationTag()}
    set {_uniqueStorage()._destinationTag = newValue}
  }
  /// Returns true if `destinationTag` has been explicitly set.
  public var hasDestinationTag: Bool {return _storage._destinationTag != nil}
  /// Clears the value of `destinationTag`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationTag() {_uniqueStorage()._destinationTag = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 2
public struct Org_Xrpl_Rpc_V1_CheckCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var checkID: Org_Xrpl_Rpc_V1_CheckID {
    get {return _storage._checkID ?? Org_Xrpl_Rpc_V1_CheckID()}
    set {_uniqueStorage()._checkID = newValue}
  }
  /// Returns true if `checkID` has been explicitly set.
  public var hasCheckID: Bool {return _storage._checkID != nil}
  /// Clears the value of `checkID`. Subsequent reads from it will return its default value.
  public mutating func clearCheckID() {_uniqueStorage()._checkID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 4
public struct Org_Xrpl_Rpc_V1_CheckCash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var checkID: Org_Xrpl_Rpc_V1_CheckID {
    get {return _storage._checkID ?? Org_Xrpl_Rpc_V1_CheckID()}
    set {_uniqueStorage()._checkID = newValue}
  }
  /// Returns true if `checkID` has been explicitly set.
  public var hasCheckID: Bool {return _storage._checkID != nil}
  /// Clears the value of `checkID`. Subsequent reads from it will return its default value.
  public mutating func clearCheckID() {_uniqueStorage()._checkID = nil}

  public var amountOneof: OneOf_AmountOneof? {
    get {return _storage._amountOneof}
    set {_uniqueStorage()._amountOneof = newValue}
  }

  public var amount: Org_Xrpl_Rpc_V1_Amount {
    get {
      if case .amount(let v)? = _storage._amountOneof {return v}
      return Org_Xrpl_Rpc_V1_Amount()
    }
    set {_uniqueStorage()._amountOneof = .amount(newValue)}
  }

  public var deliverMin: Org_Xrpl_Rpc_V1_DeliverMin {
    get {
      if case .deliverMin(let v)? = _storage._amountOneof {return v}
      return Org_Xrpl_Rpc_V1_DeliverMin()
    }
    set {_uniqueStorage()._amountOneof = .deliverMin(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_AmountOneof: Equatable {
    case amount(Org_Xrpl_Rpc_V1_Amount)
    case deliverMin(Org_Xrpl_Rpc_V1_DeliverMin)

  #if !swift(>=4.1)
    public static func ==(lhs: Org_Xrpl_Rpc_V1_CheckCash.OneOf_AmountOneof, rhs: Org_Xrpl_Rpc_V1_CheckCash.OneOf_AmountOneof) -> Bool {
      switch (lhs, rhs) {
      case (.amount(let l), .amount(let r)): return l == r
      case (.deliverMin(let l), .deliverMin(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 6
public struct Org_Xrpl_Rpc_V1_CheckCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var destination: Org_Xrpl_Rpc_V1_Destination {
    get {return _storage._destination ?? Org_Xrpl_Rpc_V1_Destination()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  public var sendMax: Org_Xrpl_Rpc_V1_SendMax {
    get {return _storage._sendMax ?? Org_Xrpl_Rpc_V1_SendMax()}
    set {_uniqueStorage()._sendMax = newValue}
  }
  /// Returns true if `sendMax` has been explicitly set.
  public var hasSendMax: Bool {return _storage._sendMax != nil}
  /// Clears the value of `sendMax`. Subsequent reads from it will return its default value.
  public mutating func clearSendMax() {_uniqueStorage()._sendMax = nil}

  public var destinationTag: Org_Xrpl_Rpc_V1_DestinationTag {
    get {return _storage._destinationTag ?? Org_Xrpl_Rpc_V1_DestinationTag()}
    set {_uniqueStorage()._destinationTag = newValue}
  }
  /// Returns true if `destinationTag` has been explicitly set.
  public var hasDestinationTag: Bool {return _storage._destinationTag != nil}
  /// Clears the value of `destinationTag`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationTag() {_uniqueStorage()._destinationTag = nil}

  public var expiration: Org_Xrpl_Rpc_V1_Expiration {
    get {return _storage._expiration ?? Org_Xrpl_Rpc_V1_Expiration()}
    set {_uniqueStorage()._expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  public var hasExpiration: Bool {return _storage._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  public mutating func clearExpiration() {_uniqueStorage()._expiration = nil}

  public var invoiceID: Org_Xrpl_Rpc_V1_InvoiceID {
    get {return _storage._invoiceID ?? Org_Xrpl_Rpc_V1_InvoiceID()}
    set {_uniqueStorage()._invoiceID = newValue}
  }
  /// Returns true if `invoiceID` has been explicitly set.
  public var hasInvoiceID: Bool {return _storage._invoiceID != nil}
  /// Clears the value of `invoiceID`. Subsequent reads from it will return its default value.
  public mutating func clearInvoiceID() {_uniqueStorage()._invoiceID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 3
public struct Org_Xrpl_Rpc_V1_DepositPreauth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authorizationOneof: OneOf_AuthorizationOneof? {
    get {return _storage._authorizationOneof}
    set {_uniqueStorage()._authorizationOneof = newValue}
  }

  public var authorize: Org_Xrpl_Rpc_V1_Authorize {
    get {
      if case .authorize(let v)? = _storage._authorizationOneof {return v}
      return Org_Xrpl_Rpc_V1_Authorize()
    }
    set {_uniqueStorage()._authorizationOneof = .authorize(newValue)}
  }

  public var unauthorize: Org_Xrpl_Rpc_V1_Unauthorize {
    get {
      if case .unauthorize(let v)? = _storage._authorizationOneof {return v}
      return Org_Xrpl_Rpc_V1_Unauthorize()
    }
    set {_uniqueStorage()._authorizationOneof = .unauthorize(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_AuthorizationOneof: Equatable {
    case authorize(Org_Xrpl_Rpc_V1_Authorize)
    case unauthorize(Org_Xrpl_Rpc_V1_Unauthorize)

  #if !swift(>=4.1)
    public static func ==(lhs: Org_Xrpl_Rpc_V1_DepositPreauth.OneOf_AuthorizationOneof, rhs: Org_Xrpl_Rpc_V1_DepositPreauth.OneOf_AuthorizationOneof) -> Bool {
      switch (lhs, rhs) {
      case (.authorize(let l), .authorize(let r)): return l == r
      case (.unauthorize(let l), .unauthorize(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 3
public struct Org_Xrpl_Rpc_V1_EscrowCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: Org_Xrpl_Rpc_V1_Owner {
    get {return _storage._owner ?? Org_Xrpl_Rpc_V1_Owner()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  public var offerSequence: Org_Xrpl_Rpc_V1_OfferSequence {
    get {return _storage._offerSequence ?? Org_Xrpl_Rpc_V1_OfferSequence()}
    set {_uniqueStorage()._offerSequence = newValue}
  }
  /// Returns true if `offerSequence` has been explicitly set.
  public var hasOfferSequence: Bool {return _storage._offerSequence != nil}
  /// Clears the value of `offerSequence`. Subsequent reads from it will return its default value.
  public mutating func clearOfferSequence() {_uniqueStorage()._offerSequence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 7
public struct Org_Xrpl_Rpc_V1_EscrowCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: Org_Xrpl_Rpc_V1_Amount {
    get {return _storage._amount ?? Org_Xrpl_Rpc_V1_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var destination: Org_Xrpl_Rpc_V1_Destination {
    get {return _storage._destination ?? Org_Xrpl_Rpc_V1_Destination()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  public var cancelAfter: Org_Xrpl_Rpc_V1_CancelAfter {
    get {return _storage._cancelAfter ?? Org_Xrpl_Rpc_V1_CancelAfter()}
    set {_uniqueStorage()._cancelAfter = newValue}
  }
  /// Returns true if `cancelAfter` has been explicitly set.
  public var hasCancelAfter: Bool {return _storage._cancelAfter != nil}
  /// Clears the value of `cancelAfter`. Subsequent reads from it will return its default value.
  public mutating func clearCancelAfter() {_uniqueStorage()._cancelAfter = nil}

  public var finishAfter: Org_Xrpl_Rpc_V1_FinishAfter {
    get {return _storage._finishAfter ?? Org_Xrpl_Rpc_V1_FinishAfter()}
    set {_uniqueStorage()._finishAfter = newValue}
  }
  /// Returns true if `finishAfter` has been explicitly set.
  public var hasFinishAfter: Bool {return _storage._finishAfter != nil}
  /// Clears the value of `finishAfter`. Subsequent reads from it will return its default value.
  public mutating func clearFinishAfter() {_uniqueStorage()._finishAfter = nil}

  public var condition: Org_Xrpl_Rpc_V1_Condition {
    get {return _storage._condition ?? Org_Xrpl_Rpc_V1_Condition()}
    set {_uniqueStorage()._condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return _storage._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {_uniqueStorage()._condition = nil}

  public var destinationTag: Org_Xrpl_Rpc_V1_DestinationTag {
    get {return _storage._destinationTag ?? Org_Xrpl_Rpc_V1_DestinationTag()}
    set {_uniqueStorage()._destinationTag = newValue}
  }
  /// Returns true if `destinationTag` has been explicitly set.
  public var hasDestinationTag: Bool {return _storage._destinationTag != nil}
  /// Clears the value of `destinationTag`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationTag() {_uniqueStorage()._destinationTag = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 5
public struct Org_Xrpl_Rpc_V1_EscrowFinish {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: Org_Xrpl_Rpc_V1_Owner {
    get {return _storage._owner ?? Org_Xrpl_Rpc_V1_Owner()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  public var offerSequence: Org_Xrpl_Rpc_V1_OfferSequence {
    get {return _storage._offerSequence ?? Org_Xrpl_Rpc_V1_OfferSequence()}
    set {_uniqueStorage()._offerSequence = newValue}
  }
  /// Returns true if `offerSequence` has been explicitly set.
  public var hasOfferSequence: Bool {return _storage._offerSequence != nil}
  /// Clears the value of `offerSequence`. Subsequent reads from it will return its default value.
  public mutating func clearOfferSequence() {_uniqueStorage()._offerSequence = nil}

  public var condition: Org_Xrpl_Rpc_V1_Condition {
    get {return _storage._condition ?? Org_Xrpl_Rpc_V1_Condition()}
    set {_uniqueStorage()._condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return _storage._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {_uniqueStorage()._condition = nil}

  public var fulfillment: Org_Xrpl_Rpc_V1_Fulfillment {
    get {return _storage._fulfillment ?? Org_Xrpl_Rpc_V1_Fulfillment()}
    set {_uniqueStorage()._fulfillment = newValue}
  }
  /// Returns true if `fulfillment` has been explicitly set.
  public var hasFulfillment: Bool {return _storage._fulfillment != nil}
  /// Clears the value of `fulfillment`. Subsequent reads from it will return its default value.
  public mutating func clearFulfillment() {_uniqueStorage()._fulfillment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 2
public struct Org_Xrpl_Rpc_V1_OfferCancel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var offerSequence: Org_Xrpl_Rpc_V1_OfferSequence {
    get {return _storage._offerSequence ?? Org_Xrpl_Rpc_V1_OfferSequence()}
    set {_uniqueStorage()._offerSequence = newValue}
  }
  /// Returns true if `offerSequence` has been explicitly set.
  public var hasOfferSequence: Bool {return _storage._offerSequence != nil}
  /// Clears the value of `offerSequence`. Subsequent reads from it will return its default value.
  public mutating func clearOfferSequence() {_uniqueStorage()._offerSequence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 5
public struct Org_Xrpl_Rpc_V1_OfferCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expiration: Org_Xrpl_Rpc_V1_Expiration {
    get {return _storage._expiration ?? Org_Xrpl_Rpc_V1_Expiration()}
    set {_uniqueStorage()._expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  public var hasExpiration: Bool {return _storage._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  public mutating func clearExpiration() {_uniqueStorage()._expiration = nil}

  public var offerSequence: Org_Xrpl_Rpc_V1_OfferSequence {
    get {return _storage._offerSequence ?? Org_Xrpl_Rpc_V1_OfferSequence()}
    set {_uniqueStorage()._offerSequence = newValue}
  }
  /// Returns true if `offerSequence` has been explicitly set.
  public var hasOfferSequence: Bool {return _storage._offerSequence != nil}
  /// Clears the value of `offerSequence`. Subsequent reads from it will return its default value.
  public mutating func clearOfferSequence() {_uniqueStorage()._offerSequence = nil}

  public var takerGets: Org_Xrpl_Rpc_V1_TakerGets {
    get {return _storage._takerGets ?? Org_Xrpl_Rpc_V1_TakerGets()}
    set {_uniqueStorage()._takerGets = newValue}
  }
  /// Returns true if `takerGets` has been explicitly set.
  public var hasTakerGets: Bool {return _storage._takerGets != nil}
  /// Clears the value of `takerGets`. Subsequent reads from it will return its default value.
  public mutating func clearTakerGets() {_uniqueStorage()._takerGets = nil}

  public var takerPays: Org_Xrpl_Rpc_V1_TakerPays {
    get {return _storage._takerPays ?? Org_Xrpl_Rpc_V1_TakerPays()}
    set {_uniqueStorage()._takerPays = newValue}
  }
  /// Returns true if `takerPays` has been explicitly set.
  public var hasTakerPays: Bool {return _storage._takerPays != nil}
  /// Clears the value of `takerPays`. Subsequent reads from it will return its default value.
  public mutating func clearTakerPays() {_uniqueStorage()._takerPays = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 8
public struct Org_Xrpl_Rpc_V1_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: Org_Xrpl_Rpc_V1_Amount {
    get {return _storage._amount ?? Org_Xrpl_Rpc_V1_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var destination: Org_Xrpl_Rpc_V1_Destination {
    get {return _storage._destination ?? Org_Xrpl_Rpc_V1_Destination()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  public var destinationTag: Org_Xrpl_Rpc_V1_DestinationTag {
    get {return _storage._destinationTag ?? Org_Xrpl_Rpc_V1_DestinationTag()}
    set {_uniqueStorage()._destinationTag = newValue}
  }
  /// Returns true if `destinationTag` has been explicitly set.
  public var hasDestinationTag: Bool {return _storage._destinationTag != nil}
  /// Clears the value of `destinationTag`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationTag() {_uniqueStorage()._destinationTag = nil}

  public var invoiceID: Org_Xrpl_Rpc_V1_InvoiceID {
    get {return _storage._invoiceID ?? Org_Xrpl_Rpc_V1_InvoiceID()}
    set {_uniqueStorage()._invoiceID = newValue}
  }
  /// Returns true if `invoiceID` has been explicitly set.
  public var hasInvoiceID: Bool {return _storage._invoiceID != nil}
  /// Clears the value of `invoiceID`. Subsequent reads from it will return its default value.
  public mutating func clearInvoiceID() {_uniqueStorage()._invoiceID = nil}

  public var paths: [Org_Xrpl_Rpc_V1_Payment.Path] {
    get {return _storage._paths}
    set {_uniqueStorage()._paths = newValue}
  }

  public var sendMax: Org_Xrpl_Rpc_V1_SendMax {
    get {return _storage._sendMax ?? Org_Xrpl_Rpc_V1_SendMax()}
    set {_uniqueStorage()._sendMax = newValue}
  }
  /// Returns true if `sendMax` has been explicitly set.
  public var hasSendMax: Bool {return _storage._sendMax != nil}
  /// Clears the value of `sendMax`. Subsequent reads from it will return its default value.
  public mutating func clearSendMax() {_uniqueStorage()._sendMax = nil}

  public var deliverMin: Org_Xrpl_Rpc_V1_DeliverMin {
    get {return _storage._deliverMin ?? Org_Xrpl_Rpc_V1_DeliverMin()}
    set {_uniqueStorage()._deliverMin = newValue}
  }
  /// Returns true if `deliverMin` has been explicitly set.
  public var hasDeliverMin: Bool {return _storage._deliverMin != nil}
  /// Clears the value of `deliverMin`. Subsequent reads from it will return its default value.
  public mutating func clearDeliverMin() {_uniqueStorage()._deliverMin = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Next field: 4
  public struct PathElement {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var account: Org_Xrpl_Rpc_V1_AccountAddress {
      get {return _storage._account ?? Org_Xrpl_Rpc_V1_AccountAddress()}
      set {_uniqueStorage()._account = newValue}
    }
    /// Returns true if `account` has been explicitly set.
    public var hasAccount: Bool {return _storage._account != nil}
    /// Clears the value of `account`. Subsequent reads from it will return its default value.
    public mutating func clearAccount() {_uniqueStorage()._account = nil}

    public var currency: Org_Xrpl_Rpc_V1_Currency {
      get {return _storage._currency ?? Org_Xrpl_Rpc_V1_Currency()}
      set {_uniqueStorage()._currency = newValue}
    }
    /// Returns true if `currency` has been explicitly set.
    public var hasCurrency: Bool {return _storage._currency != nil}
    /// Clears the value of `currency`. Subsequent reads from it will return its default value.
    public mutating func clearCurrency() {_uniqueStorage()._currency = nil}

    public var issuer: Org_Xrpl_Rpc_V1_AccountAddress {
      get {return _storage._issuer ?? Org_Xrpl_Rpc_V1_AccountAddress()}
      set {_uniqueStorage()._issuer = newValue}
    }
    /// Returns true if `issuer` has been explicitly set.
    public var hasIssuer: Bool {return _storage._issuer != nil}
    /// Clears the value of `issuer`. Subsequent reads from it will return its default value.
    public mutating func clearIssuer() {_uniqueStorage()._issuer = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Next field: 2
  public struct Path {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var elements: [Org_Xrpl_Rpc_V1_Payment.PathElement] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 6
public struct Org_Xrpl_Rpc_V1_PaymentChannelClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channel: Org_Xrpl_Rpc_V1_Channel {
    get {return _storage._channel ?? Org_Xrpl_Rpc_V1_Channel()}
    set {_uniqueStorage()._channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return _storage._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {_uniqueStorage()._channel = nil}

  public var balance: Org_Xrpl_Rpc_V1_Balance {
    get {return _storage._balance ?? Org_Xrpl_Rpc_V1_Balance()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var amount: Org_Xrpl_Rpc_V1_Amount {
    get {return _storage._amount ?? Org_Xrpl_Rpc_V1_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var paymentChannelSignature: Org_Xrpl_Rpc_V1_PaymentChannelSignature {
    get {return _storage._paymentChannelSignature ?? Org_Xrpl_Rpc_V1_PaymentChannelSignature()}
    set {_uniqueStorage()._paymentChannelSignature = newValue}
  }
  /// Returns true if `paymentChannelSignature` has been explicitly set.
  public var hasPaymentChannelSignature: Bool {return _storage._paymentChannelSignature != nil}
  /// Clears the value of `paymentChannelSignature`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentChannelSignature() {_uniqueStorage()._paymentChannelSignature = nil}

  public var publicKey: Org_Xrpl_Rpc_V1_PublicKey {
    get {return _storage._publicKey ?? Org_Xrpl_Rpc_V1_PublicKey()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 7
public struct Org_Xrpl_Rpc_V1_PaymentChannelCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: Org_Xrpl_Rpc_V1_Amount {
    get {return _storage._amount ?? Org_Xrpl_Rpc_V1_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var destination: Org_Xrpl_Rpc_V1_Destination {
    get {return _storage._destination ?? Org_Xrpl_Rpc_V1_Destination()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  public var settleDelay: Org_Xrpl_Rpc_V1_SettleDelay {
    get {return _storage._settleDelay ?? Org_Xrpl_Rpc_V1_SettleDelay()}
    set {_uniqueStorage()._settleDelay = newValue}
  }
  /// Returns true if `settleDelay` has been explicitly set.
  public var hasSettleDelay: Bool {return _storage._settleDelay != nil}
  /// Clears the value of `settleDelay`. Subsequent reads from it will return its default value.
  public mutating func clearSettleDelay() {_uniqueStorage()._settleDelay = nil}

  public var publicKey: Org_Xrpl_Rpc_V1_PublicKey {
    get {return _storage._publicKey ?? Org_Xrpl_Rpc_V1_PublicKey()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

  public var cancelAfter: Org_Xrpl_Rpc_V1_CancelAfter {
    get {return _storage._cancelAfter ?? Org_Xrpl_Rpc_V1_CancelAfter()}
    set {_uniqueStorage()._cancelAfter = newValue}
  }
  /// Returns true if `cancelAfter` has been explicitly set.
  public var hasCancelAfter: Bool {return _storage._cancelAfter != nil}
  /// Clears the value of `cancelAfter`. Subsequent reads from it will return its default value.
  public mutating func clearCancelAfter() {_uniqueStorage()._cancelAfter = nil}

  public var destinationTag: Org_Xrpl_Rpc_V1_DestinationTag {
    get {return _storage._destinationTag ?? Org_Xrpl_Rpc_V1_DestinationTag()}
    set {_uniqueStorage()._destinationTag = newValue}
  }
  /// Returns true if `destinationTag` has been explicitly set.
  public var hasDestinationTag: Bool {return _storage._destinationTag != nil}
  /// Clears the value of `destinationTag`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationTag() {_uniqueStorage()._destinationTag = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 4
public struct Org_Xrpl_Rpc_V1_PaymentChannelFund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channel: Org_Xrpl_Rpc_V1_Channel {
    get {return _storage._channel ?? Org_Xrpl_Rpc_V1_Channel()}
    set {_uniqueStorage()._channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return _storage._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {_uniqueStorage()._channel = nil}

  public var amount: Org_Xrpl_Rpc_V1_Amount {
    get {return _storage._amount ?? Org_Xrpl_Rpc_V1_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var expiration: Org_Xrpl_Rpc_V1_Expiration {
    get {return _storage._expiration ?? Org_Xrpl_Rpc_V1_Expiration()}
    set {_uniqueStorage()._expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  public var hasExpiration: Bool {return _storage._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  public mutating func clearExpiration() {_uniqueStorage()._expiration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 2
public struct Org_Xrpl_Rpc_V1_SetRegularKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var regularKey: Org_Xrpl_Rpc_V1_RegularKey {
    get {return _storage._regularKey ?? Org_Xrpl_Rpc_V1_RegularKey()}
    set {_uniqueStorage()._regularKey = newValue}
  }
  /// Returns true if `regularKey` has been explicitly set.
  public var hasRegularKey: Bool {return _storage._regularKey != nil}
  /// Clears the value of `regularKey`. Subsequent reads from it will return its default value.
  public mutating func clearRegularKey() {_uniqueStorage()._regularKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 3
public struct Org_Xrpl_Rpc_V1_SignerListSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signerQuorum: Org_Xrpl_Rpc_V1_SignerQuorum {
    get {return _storage._signerQuorum ?? Org_Xrpl_Rpc_V1_SignerQuorum()}
    set {_uniqueStorage()._signerQuorum = newValue}
  }
  /// Returns true if `signerQuorum` has been explicitly set.
  public var hasSignerQuorum: Bool {return _storage._signerQuorum != nil}
  /// Clears the value of `signerQuorum`. Subsequent reads from it will return its default value.
  public mutating func clearSignerQuorum() {_uniqueStorage()._signerQuorum = nil}

  public var signerEntries: [Org_Xrpl_Rpc_V1_SignerEntry] {
    get {return _storage._signerEntries}
    set {_uniqueStorage()._signerEntries = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Next field: 4
public struct Org_Xrpl_Rpc_V1_TrustSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limitAmount: Org_Xrpl_Rpc_V1_LimitAmount {
    get {return _storage._limitAmount ?? Org_Xrpl_Rpc_V1_LimitAmount()}
    set {_uniqueStorage()._limitAmount = newValue}
  }
  /// Returns true if `limitAmount` has been explicitly set.
  public var hasLimitAmount: Bool {return _storage._limitAmount != nil}
  /// Clears the value of `limitAmount`. Subsequent reads from it will return its default value.
  public mutating func clearLimitAmount() {_uniqueStorage()._limitAmount = nil}

  public var qualityIn: Org_Xrpl_Rpc_V1_QualityIn {
    get {return _storage._qualityIn ?? Org_Xrpl_Rpc_V1_QualityIn()}
    set {_uniqueStorage()._qualityIn = newValue}
  }
  /// Returns true if `qualityIn` has been explicitly set.
  public var hasQualityIn: Bool {return _storage._qualityIn != nil}
  /// Clears the value of `qualityIn`. Subsequent reads from it will return its default value.
  public mutating func clearQualityIn() {_uniqueStorage()._qualityIn = nil}

  public var qualityOut: Org_Xrpl_Rpc_V1_QualityOut {
    get {return _storage._qualityOut ?? Org_Xrpl_Rpc_V1_QualityOut()}
    set {_uniqueStorage()._qualityOut = newValue}
  }
  /// Returns true if `qualityOut` has been explicitly set.
  public var hasQualityOut: Bool {return _storage._qualityOut != nil}
  /// Clears the value of `qualityOut`. Subsequent reads from it will return its default value.
  public mutating func clearQualityOut() {_uniqueStorage()._qualityOut = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "org.xrpl.rpc.v1"

extension Org_Xrpl_Rpc_V1_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "fee"),
    3: .same(proto: "sequence"),
    4: .same(proto: "payment"),
    13: .standard(proto: "account_set"),
    14: .standard(proto: "account_delete"),
    15: .standard(proto: "check_cancel"),
    16: .standard(proto: "check_cash"),
    17: .standard(proto: "check_create"),
    18: .standard(proto: "deposit_preauth"),
    19: .standard(proto: "escrow_cancel"),
    20: .standard(proto: "escrow_create"),
    21: .standard(proto: "escrow_finish"),
    22: .standard(proto: "offer_cancel"),
    23: .standard(proto: "offer_create"),
    24: .standard(proto: "payment_channel_claim"),
    25: .standard(proto: "payment_channel_create"),
    26: .standard(proto: "payment_channel_fund"),
    27: .standard(proto: "set_regular_key"),
    28: .standard(proto: "signer_list_set"),
    29: .standard(proto: "trust_set"),
    5: .standard(proto: "signing_public_key"),
    6: .standard(proto: "transaction_signature"),
    7: .same(proto: "flags"),
    8: .standard(proto: "last_ledger_sequence"),
    9: .standard(proto: "source_tag"),
    10: .same(proto: "memos"),
    11: .same(proto: "signers"),
    12: .standard(proto: "account_transaction_id"),
  ]

  fileprivate class _StorageClass {
    var _account: Org_Xrpl_Rpc_V1_Account? = nil
    var _fee: Org_Xrpl_Rpc_V1_XRPDropsAmount? = nil
    var _sequence: Org_Xrpl_Rpc_V1_Sequence? = nil
    var _transactionData: Org_Xrpl_Rpc_V1_Transaction.OneOf_TransactionData?
    var _signingPublicKey: Org_Xrpl_Rpc_V1_SigningPublicKey? = nil
    var _transactionSignature: Org_Xrpl_Rpc_V1_TransactionSignature? = nil
    var _flags: Org_Xrpl_Rpc_V1_Flags? = nil
    var _lastLedgerSequence: Org_Xrpl_Rpc_V1_LastLedgerSequence? = nil
    var _sourceTag: Org_Xrpl_Rpc_V1_SourceTag? = nil
    var _memos: [Org_Xrpl_Rpc_V1_Memo] = []
    var _signers: [Org_Xrpl_Rpc_V1_Signer] = []
    var _accountTransactionID: Org_Xrpl_Rpc_V1_AccountTransactionID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _fee = source._fee
      _sequence = source._sequence
      _transactionData = source._transactionData
      _signingPublicKey = source._signingPublicKey
      _transactionSignature = source._transactionSignature
      _flags = source._flags
      _lastLedgerSequence = source._lastLedgerSequence
      _sourceTag = source._sourceTag
      _memos = source._memos
      _signers = source._signers
      _accountTransactionID = source._accountTransactionID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fee)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._sequence)
        case 4:
          var v: Org_Xrpl_Rpc_V1_Payment?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .payment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .payment(v)}
        case 5: try decoder.decodeSingularMessageField(value: &_storage._signingPublicKey)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._transactionSignature)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._flags)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._lastLedgerSequence)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._sourceTag)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._memos)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._signers)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._accountTransactionID)
        case 13:
          var v: Org_Xrpl_Rpc_V1_AccountSet?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .accountSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .accountSet(v)}
        case 14:
          var v: Org_Xrpl_Rpc_V1_AccountDelete?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .accountDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .accountDelete(v)}
        case 15:
          var v: Org_Xrpl_Rpc_V1_CheckCancel?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .checkCancel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .checkCancel(v)}
        case 16:
          var v: Org_Xrpl_Rpc_V1_CheckCash?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .checkCash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .checkCash(v)}
        case 17:
          var v: Org_Xrpl_Rpc_V1_CheckCreate?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .checkCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .checkCreate(v)}
        case 18:
          var v: Org_Xrpl_Rpc_V1_DepositPreauth?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .depositPreauth(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .depositPreauth(v)}
        case 19:
          var v: Org_Xrpl_Rpc_V1_EscrowCancel?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .escrowCancel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .escrowCancel(v)}
        case 20:
          var v: Org_Xrpl_Rpc_V1_EscrowCreate?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .escrowCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .escrowCreate(v)}
        case 21:
          var v: Org_Xrpl_Rpc_V1_EscrowFinish?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .escrowFinish(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .escrowFinish(v)}
        case 22:
          var v: Org_Xrpl_Rpc_V1_OfferCancel?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .offerCancel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .offerCancel(v)}
        case 23:
          var v: Org_Xrpl_Rpc_V1_OfferCreate?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .offerCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .offerCreate(v)}
        case 24:
          var v: Org_Xrpl_Rpc_V1_PaymentChannelClaim?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .paymentChannelClaim(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .paymentChannelClaim(v)}
        case 25:
          var v: Org_Xrpl_Rpc_V1_PaymentChannelCreate?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .paymentChannelCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .paymentChannelCreate(v)}
        case 26:
          var v: Org_Xrpl_Rpc_V1_PaymentChannelFund?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .paymentChannelFund(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .paymentChannelFund(v)}
        case 27:
          var v: Org_Xrpl_Rpc_V1_SetRegularKey?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .setRegularKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .setRegularKey(v)}
        case 28:
          var v: Org_Xrpl_Rpc_V1_SignerListSet?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .signerListSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .signerListSet(v)}
        case 29:
          var v: Org_Xrpl_Rpc_V1_TrustSet?
          if let current = _storage._transactionData {
            try decoder.handleConflictingOneOf()
            if case .trustSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transactionData = .trustSet(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._sequence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if case .payment(let v)? = _storage._transactionData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._signingPublicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._transactionSignature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._flags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._lastLedgerSequence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._sourceTag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._memos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._memos, fieldNumber: 10)
      }
      if !_storage._signers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signers, fieldNumber: 11)
      }
      if let v = _storage._accountTransactionID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      switch _storage._transactionData {
      case .accountSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .accountDelete(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .checkCancel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .checkCash(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .checkCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .depositPreauth(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .escrowCancel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .escrowCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .escrowFinish(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .offerCancel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .offerCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .paymentChannelClaim(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .paymentChannelCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .paymentChannelFund(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .setRegularKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .signerListSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case .trustSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      case nil: break
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_Transaction, rhs: Org_Xrpl_Rpc_V1_Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._fee != rhs_storage._fee {return false}
        if _storage._sequence != rhs_storage._sequence {return false}
        if _storage._transactionData != rhs_storage._transactionData {return false}
        if _storage._signingPublicKey != rhs_storage._signingPublicKey {return false}
        if _storage._transactionSignature != rhs_storage._transactionSignature {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._lastLedgerSequence != rhs_storage._lastLedgerSequence {return false}
        if _storage._sourceTag != rhs_storage._sourceTag {return false}
        if _storage._memos != rhs_storage._memos {return false}
        if _storage._signers != rhs_storage._signers {return false}
        if _storage._accountTransactionID != rhs_storage._accountTransactionID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_Memo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Memo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "memo_data"),
    2: .standard(proto: "memo_format"),
    3: .standard(proto: "memo_type"),
  ]

  fileprivate class _StorageClass {
    var _memoData: Org_Xrpl_Rpc_V1_MemoData? = nil
    var _memoFormat: Org_Xrpl_Rpc_V1_MemoFormat? = nil
    var _memoType: Org_Xrpl_Rpc_V1_MemoType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _memoData = source._memoData
      _memoFormat = source._memoFormat
      _memoType = source._memoType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._memoData)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._memoFormat)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._memoType)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._memoData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._memoFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._memoType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_Memo, rhs: Org_Xrpl_Rpc_V1_Memo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._memoData != rhs_storage._memoData {return false}
        if _storage._memoFormat != rhs_storage._memoFormat {return false}
        if _storage._memoType != rhs_storage._memoType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_Signer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Signer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "transaction_signature"),
    3: .standard(proto: "signing_public_key"),
  ]

  fileprivate class _StorageClass {
    var _account: Org_Xrpl_Rpc_V1_Account? = nil
    var _transactionSignature: Org_Xrpl_Rpc_V1_TransactionSignature? = nil
    var _signingPublicKey: Org_Xrpl_Rpc_V1_SigningPublicKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _transactionSignature = source._transactionSignature
      _signingPublicKey = source._signingPublicKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._transactionSignature)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._signingPublicKey)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._transactionSignature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._signingPublicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_Signer, rhs: Org_Xrpl_Rpc_V1_Signer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._transactionSignature != rhs_storage._transactionSignature {return false}
        if _storage._signingPublicKey != rhs_storage._signingPublicKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_AccountSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "clear_flag"),
    2: .same(proto: "domain"),
    3: .standard(proto: "email_hash"),
    4: .standard(proto: "message_key"),
    5: .standard(proto: "set_flag"),
    6: .standard(proto: "transfer_rate"),
    7: .standard(proto: "tick_size"),
  ]

  fileprivate class _StorageClass {
    var _clearFlag_p: Org_Xrpl_Rpc_V1_ClearFlag? = nil
    var _domain: Org_Xrpl_Rpc_V1_Domain? = nil
    var _emailHash: Org_Xrpl_Rpc_V1_EmailHash? = nil
    var _messageKey: Org_Xrpl_Rpc_V1_MessageKey? = nil
    var _setFlag: Org_Xrpl_Rpc_V1_SetFlag? = nil
    var _transferRate: Org_Xrpl_Rpc_V1_TransferRate? = nil
    var _tickSize: Org_Xrpl_Rpc_V1_TickSize? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _clearFlag_p = source._clearFlag_p
      _domain = source._domain
      _emailHash = source._emailHash
      _messageKey = source._messageKey
      _setFlag = source._setFlag
      _transferRate = source._transferRate
      _tickSize = source._tickSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._clearFlag_p)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._domain)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._emailHash)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._messageKey)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._setFlag)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._transferRate)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._tickSize)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._clearFlag_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._domain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._emailHash {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._messageKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._setFlag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._transferRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._tickSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_AccountSet, rhs: Org_Xrpl_Rpc_V1_AccountSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clearFlag_p != rhs_storage._clearFlag_p {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._emailHash != rhs_storage._emailHash {return false}
        if _storage._messageKey != rhs_storage._messageKey {return false}
        if _storage._setFlag != rhs_storage._setFlag {return false}
        if _storage._transferRate != rhs_storage._transferRate {return false}
        if _storage._tickSize != rhs_storage._tickSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_AccountDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountDelete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "destination_tag"),
  ]

  fileprivate class _StorageClass {
    var _destination: Org_Xrpl_Rpc_V1_Destination? = nil
    var _destinationTag: Org_Xrpl_Rpc_V1_DestinationTag? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _destination = source._destination
      _destinationTag = source._destinationTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._destination)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._destinationTag)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._destinationTag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_AccountDelete, rhs: Org_Xrpl_Rpc_V1_AccountDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._destinationTag != rhs_storage._destinationTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_CheckCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckCancel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "check_id"),
  ]

  fileprivate class _StorageClass {
    var _checkID: Org_Xrpl_Rpc_V1_CheckID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _checkID = source._checkID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._checkID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._checkID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_CheckCancel, rhs: Org_Xrpl_Rpc_V1_CheckCancel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._checkID != rhs_storage._checkID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_CheckCash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckCash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "check_id"),
    2: .same(proto: "amount"),
    3: .standard(proto: "deliver_min"),
  ]

  fileprivate class _StorageClass {
    var _checkID: Org_Xrpl_Rpc_V1_CheckID? = nil
    var _amountOneof: Org_Xrpl_Rpc_V1_CheckCash.OneOf_AmountOneof?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _checkID = source._checkID
      _amountOneof = source._amountOneof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._checkID)
        case 2:
          var v: Org_Xrpl_Rpc_V1_Amount?
          if let current = _storage._amountOneof {
            try decoder.handleConflictingOneOf()
            if case .amount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._amountOneof = .amount(v)}
        case 3:
          var v: Org_Xrpl_Rpc_V1_DeliverMin?
          if let current = _storage._amountOneof {
            try decoder.handleConflictingOneOf()
            if case .deliverMin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._amountOneof = .deliverMin(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._checkID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._amountOneof {
      case .amount(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .deliverMin(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_CheckCash, rhs: Org_Xrpl_Rpc_V1_CheckCash) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._checkID != rhs_storage._checkID {return false}
        if _storage._amountOneof != rhs_storage._amountOneof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_CheckCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .standard(proto: "send_max"),
    3: .standard(proto: "destination_tag"),
    4: .same(proto: "expiration"),
    5: .standard(proto: "invoice_id"),
  ]

  fileprivate class _StorageClass {
    var _destination: Org_Xrpl_Rpc_V1_Destination? = nil
    var _sendMax: Org_Xrpl_Rpc_V1_SendMax? = nil
    var _destinationTag: Org_Xrpl_Rpc_V1_DestinationTag? = nil
    var _expiration: Org_Xrpl_Rpc_V1_Expiration? = nil
    var _invoiceID: Org_Xrpl_Rpc_V1_InvoiceID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _destination = source._destination
      _sendMax = source._sendMax
      _destinationTag = source._destinationTag
      _expiration = source._expiration
      _invoiceID = source._invoiceID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._destination)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sendMax)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._destinationTag)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._expiration)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._invoiceID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._sendMax {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._destinationTag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._expiration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._invoiceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_CheckCreate, rhs: Org_Xrpl_Rpc_V1_CheckCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._sendMax != rhs_storage._sendMax {return false}
        if _storage._destinationTag != rhs_storage._destinationTag {return false}
        if _storage._expiration != rhs_storage._expiration {return false}
        if _storage._invoiceID != rhs_storage._invoiceID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_DepositPreauth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepositPreauth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authorize"),
    2: .same(proto: "unauthorize"),
  ]

  fileprivate class _StorageClass {
    var _authorizationOneof: Org_Xrpl_Rpc_V1_DepositPreauth.OneOf_AuthorizationOneof?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _authorizationOneof = source._authorizationOneof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Org_Xrpl_Rpc_V1_Authorize?
          if let current = _storage._authorizationOneof {
            try decoder.handleConflictingOneOf()
            if case .authorize(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._authorizationOneof = .authorize(v)}
        case 2:
          var v: Org_Xrpl_Rpc_V1_Unauthorize?
          if let current = _storage._authorizationOneof {
            try decoder.handleConflictingOneOf()
            if case .unauthorize(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._authorizationOneof = .unauthorize(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._authorizationOneof {
      case .authorize(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .unauthorize(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_DepositPreauth, rhs: Org_Xrpl_Rpc_V1_DepositPreauth) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._authorizationOneof != rhs_storage._authorizationOneof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_EscrowCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EscrowCancel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "offer_sequence"),
  ]

  fileprivate class _StorageClass {
    var _owner: Org_Xrpl_Rpc_V1_Owner? = nil
    var _offerSequence: Org_Xrpl_Rpc_V1_OfferSequence? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _owner = source._owner
      _offerSequence = source._offerSequence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._owner)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._offerSequence)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._offerSequence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_EscrowCancel, rhs: Org_Xrpl_Rpc_V1_EscrowCancel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._offerSequence != rhs_storage._offerSequence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_EscrowCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EscrowCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "destination"),
    3: .standard(proto: "cancel_after"),
    4: .standard(proto: "finish_after"),
    5: .same(proto: "condition"),
    6: .standard(proto: "destination_tag"),
  ]

  fileprivate class _StorageClass {
    var _amount: Org_Xrpl_Rpc_V1_Amount? = nil
    var _destination: Org_Xrpl_Rpc_V1_Destination? = nil
    var _cancelAfter: Org_Xrpl_Rpc_V1_CancelAfter? = nil
    var _finishAfter: Org_Xrpl_Rpc_V1_FinishAfter? = nil
    var _condition: Org_Xrpl_Rpc_V1_Condition? = nil
    var _destinationTag: Org_Xrpl_Rpc_V1_DestinationTag? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _amount = source._amount
      _destination = source._destination
      _cancelAfter = source._cancelAfter
      _finishAfter = source._finishAfter
      _condition = source._condition
      _destinationTag = source._destinationTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._destination)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._cancelAfter)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._finishAfter)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._condition)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._destinationTag)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._cancelAfter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._finishAfter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._condition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._destinationTag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_EscrowCreate, rhs: Org_Xrpl_Rpc_V1_EscrowCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._cancelAfter != rhs_storage._cancelAfter {return false}
        if _storage._finishAfter != rhs_storage._finishAfter {return false}
        if _storage._condition != rhs_storage._condition {return false}
        if _storage._destinationTag != rhs_storage._destinationTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_EscrowFinish: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EscrowFinish"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .standard(proto: "offer_sequence"),
    3: .same(proto: "condition"),
    4: .same(proto: "fulfillment"),
  ]

  fileprivate class _StorageClass {
    var _owner: Org_Xrpl_Rpc_V1_Owner? = nil
    var _offerSequence: Org_Xrpl_Rpc_V1_OfferSequence? = nil
    var _condition: Org_Xrpl_Rpc_V1_Condition? = nil
    var _fulfillment: Org_Xrpl_Rpc_V1_Fulfillment? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _owner = source._owner
      _offerSequence = source._offerSequence
      _condition = source._condition
      _fulfillment = source._fulfillment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._owner)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._offerSequence)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._condition)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._fulfillment)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._offerSequence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._condition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._fulfillment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_EscrowFinish, rhs: Org_Xrpl_Rpc_V1_EscrowFinish) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._offerSequence != rhs_storage._offerSequence {return false}
        if _storage._condition != rhs_storage._condition {return false}
        if _storage._fulfillment != rhs_storage._fulfillment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_OfferCancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OfferCancel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offer_sequence"),
  ]

  fileprivate class _StorageClass {
    var _offerSequence: Org_Xrpl_Rpc_V1_OfferSequence? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _offerSequence = source._offerSequence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._offerSequence)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._offerSequence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_OfferCancel, rhs: Org_Xrpl_Rpc_V1_OfferCancel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._offerSequence != rhs_storage._offerSequence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_OfferCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OfferCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiration"),
    2: .standard(proto: "offer_sequence"),
    3: .standard(proto: "taker_gets"),
    4: .standard(proto: "taker_pays"),
  ]

  fileprivate class _StorageClass {
    var _expiration: Org_Xrpl_Rpc_V1_Expiration? = nil
    var _offerSequence: Org_Xrpl_Rpc_V1_OfferSequence? = nil
    var _takerGets: Org_Xrpl_Rpc_V1_TakerGets? = nil
    var _takerPays: Org_Xrpl_Rpc_V1_TakerPays? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _expiration = source._expiration
      _offerSequence = source._offerSequence
      _takerGets = source._takerGets
      _takerPays = source._takerPays
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._expiration)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._offerSequence)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._takerGets)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._takerPays)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._expiration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._offerSequence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._takerGets {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._takerPays {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_OfferCreate, rhs: Org_Xrpl_Rpc_V1_OfferCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._expiration != rhs_storage._expiration {return false}
        if _storage._offerSequence != rhs_storage._offerSequence {return false}
        if _storage._takerGets != rhs_storage._takerGets {return false}
        if _storage._takerPays != rhs_storage._takerPays {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Payment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "destination"),
    3: .standard(proto: "destination_tag"),
    4: .standard(proto: "invoice_id"),
    5: .same(proto: "paths"),
    6: .standard(proto: "send_max"),
    7: .standard(proto: "deliver_min"),
  ]

  fileprivate class _StorageClass {
    var _amount: Org_Xrpl_Rpc_V1_Amount? = nil
    var _destination: Org_Xrpl_Rpc_V1_Destination? = nil
    var _destinationTag: Org_Xrpl_Rpc_V1_DestinationTag? = nil
    var _invoiceID: Org_Xrpl_Rpc_V1_InvoiceID? = nil
    var _paths: [Org_Xrpl_Rpc_V1_Payment.Path] = []
    var _sendMax: Org_Xrpl_Rpc_V1_SendMax? = nil
    var _deliverMin: Org_Xrpl_Rpc_V1_DeliverMin? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _amount = source._amount
      _destination = source._destination
      _destinationTag = source._destinationTag
      _invoiceID = source._invoiceID
      _paths = source._paths
      _sendMax = source._sendMax
      _deliverMin = source._deliverMin
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._destination)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._destinationTag)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._invoiceID)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._paths)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._sendMax)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._deliverMin)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._destinationTag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._invoiceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._paths.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._paths, fieldNumber: 5)
      }
      if let v = _storage._sendMax {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._deliverMin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_Payment, rhs: Org_Xrpl_Rpc_V1_Payment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._destinationTag != rhs_storage._destinationTag {return false}
        if _storage._invoiceID != rhs_storage._invoiceID {return false}
        if _storage._paths != rhs_storage._paths {return false}
        if _storage._sendMax != rhs_storage._sendMax {return false}
        if _storage._deliverMin != rhs_storage._deliverMin {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_Payment.PathElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Org_Xrpl_Rpc_V1_Payment.protoMessageName + ".PathElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "currency"),
    3: .same(proto: "issuer"),
  ]

  fileprivate class _StorageClass {
    var _account: Org_Xrpl_Rpc_V1_AccountAddress? = nil
    var _currency: Org_Xrpl_Rpc_V1_Currency? = nil
    var _issuer: Org_Xrpl_Rpc_V1_AccountAddress? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _currency = source._currency
      _issuer = source._issuer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._currency)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._issuer)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._currency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._issuer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_Payment.PathElement, rhs: Org_Xrpl_Rpc_V1_Payment.PathElement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_Payment.Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Org_Xrpl_Rpc_V1_Payment.protoMessageName + ".Path"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.elements)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_Payment.Path, rhs: Org_Xrpl_Rpc_V1_Payment.Path) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_PaymentChannelClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentChannelClaim"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "balance"),
    3: .same(proto: "amount"),
    4: .standard(proto: "payment_channel_signature"),
    5: .standard(proto: "public_key"),
  ]

  fileprivate class _StorageClass {
    var _channel: Org_Xrpl_Rpc_V1_Channel? = nil
    var _balance: Org_Xrpl_Rpc_V1_Balance? = nil
    var _amount: Org_Xrpl_Rpc_V1_Amount? = nil
    var _paymentChannelSignature: Org_Xrpl_Rpc_V1_PaymentChannelSignature? = nil
    var _publicKey: Org_Xrpl_Rpc_V1_PublicKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _balance = source._balance
      _amount = source._amount
      _paymentChannelSignature = source._paymentChannelSignature
      _publicKey = source._publicKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._paymentChannelSignature)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._paymentChannelSignature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_PaymentChannelClaim, rhs: Org_Xrpl_Rpc_V1_PaymentChannelClaim) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._paymentChannelSignature != rhs_storage._paymentChannelSignature {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_PaymentChannelCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentChannelCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "destination"),
    3: .standard(proto: "settle_delay"),
    4: .standard(proto: "public_key"),
    5: .standard(proto: "cancel_after"),
    6: .standard(proto: "destination_tag"),
  ]

  fileprivate class _StorageClass {
    var _amount: Org_Xrpl_Rpc_V1_Amount? = nil
    var _destination: Org_Xrpl_Rpc_V1_Destination? = nil
    var _settleDelay: Org_Xrpl_Rpc_V1_SettleDelay? = nil
    var _publicKey: Org_Xrpl_Rpc_V1_PublicKey? = nil
    var _cancelAfter: Org_Xrpl_Rpc_V1_CancelAfter? = nil
    var _destinationTag: Org_Xrpl_Rpc_V1_DestinationTag? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _amount = source._amount
      _destination = source._destination
      _settleDelay = source._settleDelay
      _publicKey = source._publicKey
      _cancelAfter = source._cancelAfter
      _destinationTag = source._destinationTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._destination)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._settleDelay)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._cancelAfter)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._destinationTag)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._settleDelay {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._cancelAfter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._destinationTag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_PaymentChannelCreate, rhs: Org_Xrpl_Rpc_V1_PaymentChannelCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._settleDelay != rhs_storage._settleDelay {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._cancelAfter != rhs_storage._cancelAfter {return false}
        if _storage._destinationTag != rhs_storage._destinationTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_PaymentChannelFund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentChannelFund"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "amount"),
    3: .same(proto: "expiration"),
  ]

  fileprivate class _StorageClass {
    var _channel: Org_Xrpl_Rpc_V1_Channel? = nil
    var _amount: Org_Xrpl_Rpc_V1_Amount? = nil
    var _expiration: Org_Xrpl_Rpc_V1_Expiration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _amount = source._amount
      _expiration = source._expiration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._channel)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._expiration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._expiration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_PaymentChannelFund, rhs: Org_Xrpl_Rpc_V1_PaymentChannelFund) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._expiration != rhs_storage._expiration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_SetRegularKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetRegularKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "regular_key"),
  ]

  fileprivate class _StorageClass {
    var _regularKey: Org_Xrpl_Rpc_V1_RegularKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _regularKey = source._regularKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._regularKey)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._regularKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_SetRegularKey, rhs: Org_Xrpl_Rpc_V1_SetRegularKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._regularKey != rhs_storage._regularKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_SignerListSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignerListSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signer_quorum"),
    2: .standard(proto: "signer_entries"),
  ]

  fileprivate class _StorageClass {
    var _signerQuorum: Org_Xrpl_Rpc_V1_SignerQuorum? = nil
    var _signerEntries: [Org_Xrpl_Rpc_V1_SignerEntry] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signerQuorum = source._signerQuorum
      _signerEntries = source._signerEntries
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._signerQuorum)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._signerEntries)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._signerQuorum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signerEntries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signerEntries, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_SignerListSet, rhs: Org_Xrpl_Rpc_V1_SignerListSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signerQuorum != rhs_storage._signerQuorum {return false}
        if _storage._signerEntries != rhs_storage._signerEntries {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Org_Xrpl_Rpc_V1_TrustSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrustSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_amount"),
    2: .standard(proto: "quality_in"),
    3: .standard(proto: "quality_out"),
  ]

  fileprivate class _StorageClass {
    var _limitAmount: Org_Xrpl_Rpc_V1_LimitAmount? = nil
    var _qualityIn: Org_Xrpl_Rpc_V1_QualityIn? = nil
    var _qualityOut: Org_Xrpl_Rpc_V1_QualityOut? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _limitAmount = source._limitAmount
      _qualityIn = source._qualityIn
      _qualityOut = source._qualityOut
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._limitAmount)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._qualityIn)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._qualityOut)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._limitAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._qualityIn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._qualityOut {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Org_Xrpl_Rpc_V1_TrustSet, rhs: Org_Xrpl_Rpc_V1_TrustSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._limitAmount != rhs_storage._limitAmount {return false}
        if _storage._qualityIn != rhs_storage._qualityIn {return false}
        if _storage._qualityOut != rhs_storage._qualityOut {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
